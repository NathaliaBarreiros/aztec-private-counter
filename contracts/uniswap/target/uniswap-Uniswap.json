{
  "transpiled": true,
  "noir_version": "1.0.0-beta.2+3278f71a05090dbd",
  "name": "Uniswap",
  "functions": [
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5972837590977953198": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 36
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "packed_note_content",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7952883935970497419": {
            "error_kind": "string",
            "string": "L1 portal address of output_asset's bridge is 0"
          },
          "9283123155612446889": {
            "error_kind": "string",
            "string": "Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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AwA4EhQTLAwTFCwOCRQsDRIJACgJAgksDgkSJgITBCEsCAAhLAwEIiwMByMsDAQkLAwHJQAQABMAJAAATywsBAAALAwiCQAoCQITACgSAh8sDR8aJgIhBAIAOB8hFDkD5QATABgAFAAaAB8gAgAJLAgBEwAoEwIaLA0aGCYCIQQCADgaIRQhPAAFAAkAFCwMCRgmAiEEAwA4GCEaABABGgEmAxMEAQAoEwIhLA4YIQAoIQIhLA4YISwMGBIGKBICEiwNEwkAKAkCCSwOCRMjAgAfAAAWDyIAABXzACgTAhgsDRgUJgIaBAIAOBgaCTsNCRQiAAAWDywNExQAKBQCFCwOFBMKOBIPFCMCABQAABYyJgIYBAA7CQEYACgTAhQsDRQUDDgIFBgjAgAYAAAWTSQAAE+zJgIYBAMAOBMYFAA4FAgYLA0YEgo4GQcTCjgTBBQjAgAUAAAWdyQAAFPSCjgSBxMKOBMEFCMCABQAABaOJAAAU+QsCAETAAABAgEmAhgEISwIACEsDBkiABAAGAAkAABT9iwEAAAsDCIUBSgAF4BHABgAOBYYFyYCGAQhLAgAISwMFyIAEAAYACQAAFP2LAQAACwMIhYmAhgEISwIACEsDBsiABAAGAAkAABT9iwEAAAsDCIXJgIZBCEsCAAhLAwSIgAQABkAJAAAU/YsBAAALAwiGAUoAB2ARwASADgcEhkmAhoEISwIACEsDBkiABAAGgAkAABT9iwEAAAsDCISJgIaBCEsCAAhLAwVIgAQABoAJAAAU/YsBAAALAwiGSYCGgQhLAgAISwMHiIAEAAaACQAAFP2LAQAACwMIhUmAhsEISwIACEsDCAiABAAGwAkAABT9iwEAAAsDCIaJgIbAoYmAhwC2CYCHQLxJgIeAoEsCAEfJwIAIAQBBQAQASABJgMfBAEAKB8CICwMICEsDh0hACghAiEsDh4hACghAiEsDhshACghAiEsDhwhACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohACghAiEsDgohLA4fEyYCGwTkJgIcBIQmAh0EJCYCHgTEJgIfBGQmAiAEpCYCIQRELAwFCSIAACEqDDgJECIjAgAiAAA+eiIAACE8LA0TEi0JgFAAEwAoEwITLQYAE4BQLAgBEwAAAQIBLQqAUAATJwIAFAQBBCwMBQkiAAAhcA0oAAmAUgAVIwIAFQAAPe0iAAAhhSYCFwQYLAgAGCwMEhksDBQaLQiAVgAbABAAFwAkAABUPCwEAAAsDBkVLAwaFiwNFRIAKBICEiwOEhUHKAAWgFIAEiYCFwQQDDgSFxgjAgAYAAAh3iQAAE+zACgVAhcAOBcSGCwNGBQmAhgEBAY4FhgZBDgZGBoCOBYaFwMwgFIAFwAYDygAF4BSABkjAgAZAAAiHSQAAFcOHAwYGgIcDBoZBBwMGRgCJgIZAggEOBkYGiYCHAIACjgcGBsjAgAbAAAiXwY4GhgeCjgeGR0jAgAdAAAiXyQAAFcgGjgUGhsmAhQCBAw4GBQcIwIAHAAAIoQiAAAieywMBQkiAAAipBg4GxoYDDgaDBsjAgAbAAAimyQAAFcyLAwYCSIAACKkAzCAVQAXABoPKAAXgFUAGyMCABsAACLBJAAAVw4cDBobAhwMGxcEHAwXGgIMOBoUFyMCABcAACLrIgAAIuIsDAUYIgAAIz4EOBkaFyYCHAIACjgcGhsjAgAbAAAjGQY4FxoeCjgeGR0jAgAdAAAjGSQAAFcgJgIaBIAYOBoXGww4Fwwa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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "_approve_bridge_and_exit_input_asset_to_L1",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "9283123155612446889": {
            "error_kind": "string",
            "string": "Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_bridge",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "fields": [
                {
                  "name": "lo",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "hi",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "std::uint128::U128"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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LAgBDwAAAQIBLA4RDywIAREAAAECASwOExEmAhMEBCwMCQUiAAAHMAw4BRMUIwIAFAAADV4iAAAHQiYCEwQULAgAFCwMBxUsDAwWLAwPFywMERgAEAATACQAABJuLAQAACwMFRAmAgcALiwIAQwmAg8EBgAQAQ8BJgMMBAEAKAwCDywMDxEsDgcRACgRAhEsDgERACgRAhEsDgYRACgRAhEsDggRACgRAhEsDhARJgIPBBMsCAATLAwLFAAQAA8AJAAAEccsBAAALAwUASwMFQYsDBYHLAwXCCwNAQsAKAsCCywOCwEsCAELAAABAgEsDgELLA0GAQAoAQIBLA4BBiwIAQEAAAECASwOBgEsCAEGAAABAgEsDgcGLAgBBwAAAQIBLA4IBywMCQUiAAAIOAw4BRIIIwIACAAADO4iAAAISiYCCAQPLAgADywMCxAsDAERLAwGEiwMBxMAEAAIACQAABJuLAQAACwMEAUoAgABALg53pEmAgcEAyYCCwQDADgHCwgsCAEGABABCAEmAwYEAQAoBgIILA4HCAAoCAIILA4HCCYCCAQDADgGCAcsDAcILA4BCAAoCAIILA4FCAAoCAIILQqAQwAILA0GAQAoAQIBLA4BBiwIAQEmAgUEAwAQAQUBJgMBBAEAKAECBSwMBQctCoBEAAcAKAcCBy0KgEQABwAoAQIFACgGAgssDQsIJgIMBAIAOAsMBzgDpQAFgEMABwAIAAsgAgAFLAgBBwAoBwIPLA0PDCYCEAQCADgPEAghPAAJAAUACCwMBQwmAhAEAwA4DBAPABABDwEmAwcEAQAoBwIQLA4MEAAoEAIQLA4MECwMDAYGKAYCBiwNBwUAKAUCBSwOBQcjAgALAAAJviIAAAmiACgHAgssDQsIJgIMBAIAOAsMBTsNBQgiAAAJvgo4BgkFIwIABQAACdQmAgcEADsJAQcuCIBDAAUcDAUGACsCAAcAAAAAAAAAAAAAAAAA//////////////////////////8OOAYHCCMCAAgAAAoWJAAAEvImAgcEACYCCwQDADgHCwgsCAEGABABCAEmAwYEAQAoBgIILA4HCAAoCAIILA4HCCYCCAQDADgGCAcmAggEASYCDAQDADgIDAssCAEHABABCwEmAwcEAQAoBwILLA4ICwAoCwILLA4ICyYCCwQDADgHCwgsDAgL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",
      "debug_symbols": "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",
      "brillig_names": [
        "_approve_bridge_and_exit_input_asset_to_L1"
      ]
    },
    {
      "name": "swap_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16275222249430394394": {
            "error_kind": "string",
            "string": "input_asset address is not the same as seen in the bridge contract"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7952883935970497419": {
            "error_kind": "string",
            "string": "L1 portal address of output_asset's bridge is 0"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "input_asset",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "input_asset_bridge",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "input_amount",
            "type": {
              "fields": [
                {
                  "name": "lo",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "hi",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "std::uint128::U128"
            },
            "visibility": "private"
          },
          {
            "name": "output_asset_bridge",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce_for_transfer_to_public_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "uniswap_fee_tier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "minimum_output_amount",
            "type": {
              "fields": [
                {
                  "name": "lo",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "hi",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "std::uint128::U128"
            },
            "visibility": "private"
          },
          {
            "name": "secret_hash_for_L1_to_l2_message",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_L1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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jb+dO34L7PhrWX9dvd397PX2airtNteq6N1Ua5vtkKwNtGr57tVfMyOemU5m1DPTyUycNjNR18zYVmbMM9PJDPtG45WZYXftn5mZ9JaZIhuZYbfAr8wMvJ98YWbgnepn7tp3mdHHzKR5e+D1Tk615Y3MzNsD72Vm3h54LzPz9sB3OtM2+plkF8pMzW/fD8S0k5rPM660rTmPYc+LimuBJEb5OeMqXaltn76YV7rTgBTzZZZyutLN0fTFvNL93LBifk0N/YYurV89tJj3Gi27vXW5nwV1a+JqXaPWWuUujq+JyfT7uZclhn4797LE0O/mXpYY+s3cyxJjnpjtxNDvi16WGPo9xssSQ+/XX5YYeu/7ssR457udmOKdbycx3vl2EuOdbycx3vl2EmOemO3EeOfbSYx3vp3EeOfbSYx3vp3EeOe7nZjqnW8nMd75dhLjnW8nMd75dhJjnpjtxHjn20mMd76dxHjn20mMd76dxHjnu52Y5p1vJzHe+XYS451vJzHe+XYSY56Y7cR459tJjHe+ncR459tJjHe+ncR457uZGAne+XYSc6XO9+1aaw3fJebrtV6pmd271iv1py3f/U6W7Mx4K+V2jVbDXWom+Z2sJYVe+llLf6V7DC/9h0p/pbsoL/2HSn+l+0Qv/YdKf6U7YS/9h0p/pXt9L/1HSi9XcjO89B8q/ZX8Gi/9h0p/JfvKS/+h0rubN23pzUs/a+ndzZu29O7mTVt6d/OmLb27edOW3t28WUuv7uZNW3p386Ytvbt505be3bxpS29e+llL727etKV3N2/a0rubN23p3c2btvTu5s1a+uhu3rSldzdv2tK7mzdt6d3Nm7b05qWftfTu5k1benfzpi29u3nTlt7dvGlL727erKU3d/OmLb27edOW3t28aUvvbt60pTcv/ayldzdv2tK7mzdt6d3Nm7b07uZNW3p382YtfXI3b9rSu5s3bendzZu29O7mTVt689LPWnp386Ytvbt505be3bxpS+9u3rSldzdv1tJnd/OmLb27edOW3t28aUvvbt60pTcv/ayldzdv2tK7mzdt6d3Nm7b07uZNW3p382YtfXE3b9rSu5s3bendzZu29O7mTVt689LPWnp386Ytvbt505be3bxpS+9u3rSldzdv1tJXd/OmLb27edOW3t28aUvvbt60pTcv/ayldzdv2tK7mzdt6d3Nm7b07uZNW3p382YtfXM3b9rSu5s3bendzZu29O7mTVt689LPWnp386Ytvbt505be3bxpS+9u3rSldzdv0tJrcDdv2tK7mzdt6d3Nm7b07uZNW3rz0s9aenfzpi29u3nTlt7dvGlL727etKV3N2/W0ou7edOW3t28aUvvbt60pXc3b9rSm5d+1tK7mzdt6d3Nm7b07uZNW3p386Ytvbt5s5Ze3c2btvTu5k1benfzpi29u3nTlt689LOW3t28aUvvbt60pXc3b9rSu5s3bendzZu19NHdvGlL727etKV3N2/a0rubN23pzUs/a+ndzZu29O7mTVt6d/OmLb27edOW3t28WUtv7uZNW3p386Ytvbt505be3bxpS29e+llL727etKV3N2/a0rubN23p3c2btvTu5s1a+uRu3rSldzdv2tK7mzdt6d3Nm7b05qWftfTu5k1benfzpi29u3nTlt7dvGlL727erKXP7uZNW3p386Ytvbt505be3bxpS29e+llL727etKV3N2/a0rubN23p3c2btvTu5s1a+uJu3rSldzdv2tK7mzdt6d3Nm7b05qWftfTu5k1benfzpi29u3nTlt7dvGlL727erKWv7uZNW3p386Ytvbt505be3bxpS29e+llL727etKV3N2/a0rubN23p3c2btvTu5s1a+uZu3rSldzdv2tK7mzdt6d3Nm7b05qWftfTu5k1benfzpi29u3nTlt7dvGlL727epKWPwd28aUvvbt60pae7eUF6pf8aP9uS0hTz+uq7Wm1PXVG129VqfJszMaatiR7r7dXNQrmLZGsy5nC7yJjl7iLr1ovV9PZitXr/4q9JN0/685POtmEumnS2AXLRpLOth5MmPZbbO8d4H/Ut6eyb/osmnX27fdKkm6xJXxyN91+sNd7eWZeefufFYrd3VsnyUE5h30J7OX94sUq8vVjvby62XpzK7bWptfvL+1p59h20V/7zKs++gfbKf17l3Xo4V+XT6rFp1Z+qvHnlJ628mzCnqnxc7X2NrTw27G7vXKqcbhxdqpxuSZ2qnCnomg+T91+8VG79TjeH+Fh7d8amrb26jXbd2pe1ilLuU/3xXlzdc/Np8humiRt0Pk1+wzRxN+/C02QtvZT2U6avmk8Tnyb708R9wpdPkzdzodadd977Yl/dJzxVOcd9yaduKc5aeXcfz1X5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",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "build_msg_block",
        "attach_len_to_msg_block",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAuspryVeqpz\nWB9NUCdJ6/tL7qD58b46x2KvALZEv26qAOawPnxXV5Kav5DL/SzYaFIXxLx9+6IvkBLGet4Nv5cB\nXALdtSurinl59yohL8OdK95NelziQvXuODcuaiQRbi4CSQntJ+QVajz8Eiq6f0ndNILPkwQydxik\n3AVsypDCLnyC+I4ipf9EjBCY+n/Kd+PgzHL3SZz/rjP7AYuI7NUIuEtZgD0TNMpe/tKAnRUAc/1R\nmInx3hnS5N7nqGtHIS/4qYL7+1CHGYtgPFMLoCYSqWNTqJ6U+MABERo6vtSaMDHktGM68CgolBW5\ngq915MCQHsISs3Nbj0Yn/a7nmW8E9haTy0Qqq+0hrC+Qw1CL/xOvPZ2bfAZXGmhe4mZ2zyHvJwZQ\n0/60/RQ39Cib+3qbuKA1DMUWsvFD1sxNqx3OECpf2nMocGrkxVZXy7YKmYVmbqBAPfyoeAwS04tf\nkzcJd6vlZd0xukoWHeTyDLZBHSknC47RxnWGIzW1tf/T3ARWu3AbWwtGO7zwxP5xkFUjk9CVM+Gy\nAEvYTp+KU6iPA4D05rswR3a/1Psi4gmHdBVkgemj+PCR0w2xADptqrQNSpupQ8sieAz0M9ZqijiJ\nKaOaU8rTgOLFpoF8dxafCQdvfrLqRxEClM2RJE4j2X+5Yjg2csmusm+0KaWSieORI0ZtBz4nknD4\nSgaHJOSEBAJGkOsr7qEvadwV5V9rnmkjPU5r9YbjWf/dqg0qvgDzerHftl6wHSN8sw63LJ7dhhKx\nftwBVHQBtvBXGJ6dh3j/u60ZzvIhR1+3kJCK94yQGpOu7JXS2pxsSkeyUttu2R8n5LFni/6NlE6m\n5z5W2NMAph3qx2s3DKT0L3OmZct1qevcWM1L34r35/z/o21bcS5ZeJ8Nnbs/Fa3lOEt4SQ2x2DN5\nxzvkESPev8iMn8jWK3KtwTdDjKDTNxRFpXqWkOZE9YS6+kVBJM8BrVvgsTkBGeJB7rvr/1x9fyDc\nbFrRtq943CBtf3eFPwX95+vTci09ncQwqlMq4CvNqBOkm/J1Duc+MQQbPKNTUsukC0dRI7qqNDcD\nDdzAmzZNY/59jdcBRK0GdpV51gXTqtLp55oRr3HfGe4zWdz4iMrlIS2pDzKGQirLOok05O19Bf7h\nlyhimle0IQUHT+k+qnJS3E5n2gr5EJzpGvpbakZGYVqrIG4YBzkw5lLjpbsWE/0JITnoL2sNP2dU\n1opCygSmCxsfva/wVHDhx94qRbsXzKieW7ZEhrq7wdUbzsSc21INYBbDprf8+6I54hrnw4MpOmqC\nU+IqLzA9dJpFmrg4MbbcGajYJJL3Bf2T6AK2DKQV9yisRvnURdd4HsHM90QCRGkNSxGjnOm1oU5U\nsrYhXp1ZUEGkj3pxwuZMRl1bg0nRbjAKllehn1JMiJpomo9hIw30jwq/vGo8mgsfD9LzJOuuHr7W\n38kPXCFJhoqTrBQ17QjaWuN17CCvTa1TIfhmGssjtcM0Yf3ptIuQCzFnoiEG7QyCN6W8xY9vuPCI\nQtKyyCNg+Eon3P18nVoySdvdQLf27TeCEYwNi/z4Ii7wBwdIDLHOM3eSnS+68utFP03Cd3P1esdM\naAzFyZtdC77KODIEtYOTjsXYZm+T1CUW/ensH3zg7iL8qdr3z2URbDDT+hWV9yee1TC/1p2rHe8o\nBIOm9vU1xZpNt3BsjF+5VT2dKvSfk7/oN8/kP9srCBlMFrFfstov5HkcwCT8FEwe4kIGSzhREWi5\nOSjkIX2zZmZWSEpy2qf7n//y8iSVBo1tKBJb5ugSZln8Sm0p/b8wrTMCiuJ5AYPFlReEHE/bYGOK\nHPwSUr1ie5wEG17g36Jotcag9jShOjVl/f2A3AT5oYYQKKrcdTbI9eDrQvsasaNRrFtBnahWobyJ\ntJQyGFL3ywB2F2gJnOHRVG/Bxdk/CjtqPTJfX89l3gZv58BueZXXAWszdW7ZGSCfTW9caTziEkHL\nasnPFO6c8gr5yfNxJuoDCFNT8Uqdqwc8wZO5i0exkJD8MC6mlBb31PhzCo6IGixElClrYoH2m3nz\nLWCk4KRWyi/4b2MYc/5sNwYgZexALZvnOSgG1Hp5HrdnsKSWDU1eyfbWDVjc/mOAKqjLEKAOnnzo\nnrwmT9xpaUeQlWnS6Nx8yrFsTuHBSbQKhxl7vCDtQq4E8NraFolUJHckASv9dX/hNA/z8wVI4XPF\nTy4NAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAhQbMVnTVDrOL7vaHkiJhM9yCVFBQkq4UTp2LLlyDBgXJd/9VxTKfKK7aXVNzUYq\nnWfxTMkW7tu2mIKjacrEBNAPy7+dPPQCuqPu2l8Knkm1werJWyZMMC3IVObyLXMw3yg+39qJyUgF\nl/CzRC6XUt751Y/Ckgg2GUJh97Fj/vuvHViqYcZK1SIEPXnEgCIZ5Vuhl1Gt/mw2Mk0/tsLaCYkt\nfBipPD2uWICfqu7GqGp49LO8YfGdbnBpNZu/R+f5Bw=="
    },
    {
      "name": "swap_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7952883935970497419": {
            "error_kind": "string",
            "string": "L1 portal address of output_asset's bridge is 0"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "input_asset_bridge",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "input_amount",
            "type": {
              "fields": [
                {
                  "name": "lo",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "hi",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "std::uint128::U128"
            },
            "visibility": "private"
          },
          {
            "name": "output_asset_bridge",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce_for_transfer_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "uniswap_fee_tier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "minimum_output_amount",
            "type": {
              "fields": [
                {
                  "name": "lo",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "hi",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "std::uint128::U128"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "secret_hash_for_L1_to_l2_message",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_L1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce_for_swap_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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FwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAoFwIXLA4LFwAo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",
      "debug_symbols": "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",
      "brillig_names": [
        "swap_public"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8861757336002045335": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 99
          },
          "9862881900111276825": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 35
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "bY/dCoMwDIXfJde9aOz8ma8iQ6pGKZRWah0M8d0Xh2xu8+aQE74cchboqJmH2rjeT1BWC1jf6mi8Y7esAppgrDVDfVyD3ATVi59G7TY7RR0ilEopAeQ6ni7I972xBGWWrOIPRSmLYodRIqZvHNNzHvP8w1+zL/62sr3rYHRjaX++n1176BIfI/3UGoNvqZsDbQUP3VgrTEUiOZajnw==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "portal_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "TokenBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Uniswap"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "portal_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "fields": [
                        {
                          "name": "lo",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "hi",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::uint128::U128"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::_approve_bridge_and_exit_input_asset_to_L1_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::_approve_bridge_and_exit_input_asset_to_L1_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_amount",
                    "type": {
                      "fields": [
                        {
                          "name": "lo",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "hi",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::uint128::U128"
                    }
                  },
                  {
                    "name": "output_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce_for_transfer_approval",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "uniswap_fee_tier",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "minimum_output_amount",
                    "type": {
                      "fields": [
                        {
                          "name": "lo",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "hi",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::uint128::U128"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "secret_hash_for_L1_to_l2_message",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "caller_on_L1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "nonce_for_swap_approval",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::swap_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::swap_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "portal_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "input_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_amount",
                    "type": {
                      "fields": [
                        {
                          "name": "lo",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "hi",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::uint128::U128"
                    }
                  },
                  {
                    "name": "output_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce_for_transfer_to_public_approval",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "uniswap_fee_tier",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "minimum_output_amount",
                    "type": {
                      "fields": [
                        {
                          "name": "lo",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "hi",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::uint128::U128"
                    }
                  },
                  {
                    "name": "secret_hash_for_L1_to_l2_message",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "caller_on_L1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::swap_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::swap_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "104": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        /// Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "108": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "114": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "123": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |packed_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::unpack_content,\n///             note_header,\n///             true,\n///             storage_slot,\n///             packed_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, packed_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                header,\n                storage_slot,\n                note_type_id,\n            )\n                .unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        packed_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let packed_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, packed_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n"
    },
    "134": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header, storage_slot);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash(storage_slot);\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note, storage_slot: Field) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note, storage_slot);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    unpack_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    storage_slot: Field,\n    packed_note_content: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = unpack_content(array::subarray(packed_note_content, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash(storage_slot);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context(storage_slot)\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "137": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "139": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "140": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "147": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "151": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n"
    },
    "152": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note_content,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note_content: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::unpack_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "154": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "163": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: U128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "185": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "186": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "194": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            /// Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "211": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "247": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "254": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "255": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "269": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "271": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "287": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "288": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "297": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "313": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "317": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::{Packable, ToField};\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for U128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self.to_field()]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "318": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        // The below warning is due to visibility in noir stdlib.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "334": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    /// Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "335": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "337": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "349": {
      "path": "/Users/nathalia/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "353": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-contracts/contracts/token_contract/src/main.nr",
      "source": "// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\npub contract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::log_assembly_strategies::default_aes128::{\n            event::encode_and_encrypt_event_unconstrained,\n            note::{encode_and_encrypt_note, encode_and_encrypt_note_unconstrained},\n        },\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n    };\n\n    use dep::uint_note::uint_note::UintNote;\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::balance_set::BalanceSet;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: U128,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: PublicImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> U128 {\n        storage.total_supply.read()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> U128 {\n        storage.public_balances.at(owner).read()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_to_public\n    #[public]\n    fn mint_to_public(to: AztecAddress, amount: U128) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_to_public\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_in_public\n\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: U128, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: U128) {\n        let from = context.msg_sender();\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from,\n            from,\n        ));\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_in_private`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount }.emit(encode_and_encrypt_event_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::zero(), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining)\n    }\n\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: U128) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            amount,\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:burn_private\n    #[private]\n    fn burn_private(from: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn_private\n\n    // docs:start:transfer_to_private\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    #[private]\n    fn transfer_to_private(to: AztecAddress, amount: U128) {\n        // `from` is the owner of the public balance from which we'll subtract the `amount`.\n        let from = context.msg_sender();\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_private\n\n    // docs:start:prepare_private_balance_increase\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_to_private`, `finalize_mint_to_private`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n    // docs:end:prepare_private_balance_increase\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = UintNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let setup_log = note_setup_payload.encrypt_log(context, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // docs:start:finalize_transfer_to_private\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_to_private(amount: U128, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    /// This is a wrapper around `_finalize_transfer_to_private` placed here so that a call\n    /// to `_finalize_transfer_to_private` can be enqueued. Called unsafe as it does not check `from` (this has to be\n    /// done in the calling function).\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:mint_to_private\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueued call).\n    #[private]\n    fn mint_to_private(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        amount: U128,\n    ) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_to_private_unsafe(context.msg_sender(), amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n    // docs:end:mint_to_private\n\n    // docs:start:finalize_mint_to_private\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_to_public`\n    /// and `finalize_transfer_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_to_private(amount: U128, hiding_point_slot: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private\n\n    // docs:start:finalize_mint_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_mint_to_private_unsafe(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_to_private` function.\n        assert(storage.minters.at(from).read(), \"caller is not minter\");\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_mint_to_private(\n        amount: U128,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // First we increase the total supply by the `amount`\n        let supply = storage.total_supply.read().add(amount);\n        storage.total_supply.write(supply);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: U128) {\n        _increase_public_balance_inner(to, amount, storage);\n    }\n    // docs:end:increase_public_balance\n\n    #[contract_library_method]\n    fn _increase_public_balance_inner(\n        to: AztecAddress,\n        amount: U128,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n    }\n\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: U128) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub U128 {\n        storage.balances.at(owner).balance_of()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"
    },
    "372": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress,\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n        traits::{Packable, Serialize},\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\n#[derive(Serialize)]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self, storage_slot: Field) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self, storage_slot);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "374": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-contracts/contracts/token_bridge_contract/src/main.nr",
      "source": "mod config;\n\n// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract TokenBridge {\n    use crate::config::Config;\n\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_to_private_content_hash, get_mint_to_public_content_hash,\n        get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{functions::{initializer, private, public, view}, storage::storage};\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal: EthAddress) {\n        storage.config.initialize(Config { token, portal });\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    // docs:start:get_config\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n    // docs:end:get_config\n\n    #[public]\n    #[view]\n    fn get_config_public() -> Config {\n        storage.config.read()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: U128, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_to_public_content_hash(to, amount);\n\n        let config = storage.config.read();\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, config.portal, message_leaf_index);\n\n        // Mint tokens\n        Token::at(config.token).mint_to_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: U128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        let config = storage.config.read();\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(config.token).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n\n    // docs:start:claim_private\n    /// Claims the bridged tokens and makes them accessible in private. Note that recipient's address is not revealed\n    /// but the amount is. Hence it's most likely possible to determine to which L1 deposit this claim corresponds to\n    /// (unless there are multiple pending deposits of the same amount).\n    #[private]\n    fn claim_private(\n        recipient: AztecAddress, // recipient of the bridged tokens\n        amount: U128,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n        message_leaf_index: Field,\n    ) {\n        let config = storage.config.read();\n\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_to_private_content_hash(amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            config.portal,\n            message_leaf_index,\n        );\n\n        // At last we mint the tokens\n        // docs:start:call_mint_on_token\n        Token::at(config.token).mint_to_private(context.msg_sender(), recipient, amount).call(\n            &mut context,\n        );\n        // docs:end:call_mint_on_token\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: U128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // docs:start:assert_token_is_same\n        let config = storage.config.read();\n\n        // Assert that user provided token address is same as seen in storage.\n        assert_eq(config.token, token, \"Token address is not the same as seen in storage\");\n        // docs:end:assert_token_is_same\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(token).burn_private(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_private\n}\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "60": {
      "path": "std/uint128.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\nuse crate::static_assert;\nuse super::{convert::AsPrimitive, default::Default};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        static_assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                /// Safety: optionally adds 32 and then check (below) the result is in 'a..f' range\n                let ascii =\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128\n    where\n        T: AsPrimitive<Field>,\n    {\n        let f = i.as_();\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T\n    where\n        Field: AsPrimitive<T>,\n    {\n        AsPrimitive::as_(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        /// Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n        /// Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        /// Safety: cf div() above\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nimpl Default for U128 {\n    fn default() -> Self {\n        U128::zero()\n    }\n}\n\nmod tests {\n    use crate::default::Default;\n    use crate::ops::Not;\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        /// Safety: testing context\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq(U128::default(), U128::zero());\n    }\n}\n"
    },
    "62": {
      "path": "/Users/nathalia/Personal/cryptography/aztec/aztec-private-counter/contracts/uniswap/src/main.nr",
      "source": "// docs:start:uniswap_setup\nmod util;\n\n// Demonstrates how to use portal contracts to swap on L1 Uniswap with funds on L2\n// Has two separate flows for private and public respectively\n// Uses the token bridge contract, which tells which input token we need to talk to and handles the exit funds to L1\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Uniswap {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector, PublicImmutable};\n\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit_public, compute_authwit_message_hash_from_call,\n        set_authorized,\n    };\n\n    use crate::util::{compute_swap_private_content_hash, compute_swap_public_content_hash};\n    use dep::aztec::macros::{functions::{initializer, internal, private, public}, storage::storage};\n    use dep::token::Token;\n    use dep::token_bridge::TokenBridge;\n\n    #[storage]\n    struct Storage<Context> {\n        portal_address: PublicImmutable<EthAddress, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal_address: EthAddress) {\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:uniswap_setup\n\n    // docs:start:swap_public\n    #[public]\n    fn swap_public(\n        sender: AztecAddress,\n        input_asset_bridge: AztecAddress,\n        input_amount: U128,\n        output_asset_bridge: AztecAddress,\n        // params for using the transfer approval\n        nonce_for_transfer_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field,\n        minimum_output_amount: U128,\n        // params for the depositing output_asset back to Aztec\n        recipient: AztecAddress,\n        secret_hash_for_L1_to_l2_message: Field,\n        caller_on_L1: EthAddress,\n        // nonce for someone to call swap on sender's behalf\n        nonce_for_swap_approval: Field,\n    ) {\n        if (!sender.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, sender);\n        }\n\n        let input_asset_bridge_config =\n            TokenBridge::at(input_asset_bridge).get_config_public().view(&mut context);\n\n        let input_asset = input_asset_bridge_config.token;\n        let input_asset_bridge_portal_address = input_asset_bridge_config.portal;\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_in_public(\n                sender,\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .call(&mut context);\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n        let output_asset_bridge_portal_address =\n            TokenBridge::at(output_asset_bridge).get_config_public().view(&mut context).portal;\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        assert(\n            !output_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of output_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_swap_public_content_hash(\n            input_asset_bridge_portal_address,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_portal_address,\n            minimum_output_amount,\n            recipient,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read(), content_hash);\n    }\n    // docs:end:swap_public\n\n    // docs:start:swap_private\n    #[private]\n    fn swap_private(\n        input_asset: AztecAddress, // since private, we pass here and later assert that this is as expected by input_bridge\n        input_asset_bridge: AztecAddress,\n        input_amount: U128,\n        output_asset_bridge: AztecAddress,\n        // params for using the transfer_to_public approval\n        nonce_for_transfer_to_public_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field, // which uniswap tier to use (eg 3000 for 0.3% fee)\n        minimum_output_amount: U128, // minimum output amount to receive (slippage protection for the swap)\n        // params for the depositing output_asset back to Aztec\n        secret_hash_for_L1_to_l2_message: Field, // for when l1 uniswap portal inserts the message to consume output assets on L2\n        caller_on_L1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n    ) {\n        let input_asset_bridge_config =\n            TokenBridge::at(input_asset_bridge).get_config().view(&mut context);\n        let output_asset_bridge_config =\n            TokenBridge::at(output_asset_bridge).get_config().view(&mut context);\n\n        // Assert that user provided token address is same as expected by token bridge.\n        // we can't directly use `input_asset_bridge.token` because that is a public method and public can't return data to private\n        assert(\n            input_asset.eq(input_asset_bridge_config.token),\n            \"input_asset address is not the same as seen in the bridge contract\",\n        );\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_to_public(\n                context.msg_sender(),\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_to_public_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .enqueue(&mut context);\n\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_config.portal.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        assert(\n            !output_asset_bridge_config.portal.is_zero(),\n            \"L1 portal address of output_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_swap_private_content_hash(\n            input_asset_bridge_config.portal,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_config.portal,\n            minimum_output_amount,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read(), content_hash);\n    }\n    // docs:end:swap_private\n\n    // docs:start:authwit_uniswap_set\n    // This helper method approves the bridge to burn this contract's funds and exits the input asset to L1\n    // Assumes contract already has funds.\n    // Assume `token` relates to `token_bridge` (ie token_bridge.token == token)\n    // Note that private can't read public return values so created an internal public that handles everything\n    // this method is used for both private and public swaps.\n    #[public]\n    #[internal]\n    fn _approve_bridge_and_exit_input_asset_to_L1(\n        token: AztecAddress,\n        token_bridge: AztecAddress,\n        amount: U128,\n    ) {\n        // Since we will authorize and instantly spend the funds, all in public, we can use the same nonce\n        // every interaction. In practice, the authwit should be squashed, so this is also cheap!\n        let nonce = 0xdeadbeef;\n\n        let selector = FunctionSelector::from_signature(\"burn_public((Field),Field,Field)\");\n        let serialized_amount = amount.serialize();\n        let message_hash = compute_authwit_message_hash_from_call(\n            token_bridge,\n            token,\n            context.chain_id(),\n            context.version(),\n            selector,\n            [context.this_address().to_field(), serialized_amount[0], serialized_amount[1], nonce],\n        );\n\n        // We need to make a call to update it.\n        set_authorized(&mut context, message_hash, true);\n\n        let this_portal_address = storage.portal_address.read();\n        // Exit to L1 Uniswap Portal !\n        TokenBridge::at(token_bridge)\n            .exit_to_l1_public(this_portal_address, amount, this_portal_address, nonce)\n            .call(&mut context)\n    }\n    // docs:end:authwit_uniswap_set\n}"
    },
    "64": {
      "path": "/Users/nathalia/Personal/cryptography/aztec/aztec-private-counter/contracts/uniswap/src/util.nr",
      "source": "// docs:start:uniswap_public_content_hash\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// This method computes the L2 to L1 message content hash for the public\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_public_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: U128,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: U128,\n    aztec_recipient: AztecAddress,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 260]; // 8 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_field().to_be_bytes();\n    let uniswap_fee_tier_bytes: [u8; 32] = uniswap_fee_tier.to_be_bytes();\n    let output_token_portal_bytes: [u8; 32] =\n        output_asset_bridge_portal_address.to_field().to_be_bytes();\n    let amount_out_min_bytes: [u8; 32] = minimum_output_amount.to_field().to_be_bytes();\n    let aztec_recipient_bytes: [u8; 32] = aztec_recipient.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime {\n        keccak256::keccak256(\n            \"swap_public(address,uint256,uint24,address,uint256,bytes32,bytes32,address)\".as_bytes(),\n            75,\n        )\n    };\n\n    hash_bytes[0] = selector[0];\n    hash_bytes[1] = selector[1];\n    hash_bytes[2] = selector[2];\n    hash_bytes[3] = selector[3];\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = aztec_recipient_bytes[i];\n        hash_bytes[i + 196] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 228] = caller_on_L1_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:uniswap_public_content_hash\n\n// docs:start:compute_swap_private_content_hash\n// This method computes the L2 to L1 message content hash for the private\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_private_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: U128,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: U128,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 228]; // 7 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_field().to_be_bytes();\n    let uniswap_fee_tier_bytes: [u8; 32] = uniswap_fee_tier.to_be_bytes();\n    let output_token_portal_bytes: [u8; 32] =\n        output_asset_bridge_portal_address.to_field().to_be_bytes();\n    let amount_out_min_bytes: [u8; 32] = minimum_output_amount.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime {\n        keccak256::keccak256(\n            \"swap_private(address,uint256,uint24,address,uint256,bytes32,address)\".as_bytes(),\n            68,\n        )\n    };\n\n    hash_bytes[0] = selector[0];\n    hash_bytes[1] = selector[1];\n    hash_bytes[2] = selector[2];\n    hash_bytes[3] = selector[3];\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 196] = caller_on_L1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:compute_swap_private_content_hash\n\n"
    },
    "66": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "75": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "82": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "83": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "84": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "85": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "97": {
      "path": "/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
