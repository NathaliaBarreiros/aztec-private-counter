{"noir_version":"1.0.0-beta.2+3278f71a05090dbd","name":"Uniswap","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"packed_note_content","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5972837590977953198":{"error_kind":"fmtstring","length":36,"item_types":[{"kind":"field"}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"939615093317106671":{"error_kind":"string","string":"Invalid response from registry"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4939791462094160055":{"error_kind":"string","string":"Message not authorized by account"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7952883935970497419":{"error_kind":"string","string":"L1 portal address of output_asset's bridge is 0"},"9283123155612446889":{"error_kind":"string","string":"Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16541607464495309456":{"error_kind":"fmtstring","length":16,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17695220409134080280":{"error_kind":"string","string":"L1 portal address of input_asset's bridge is 0"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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o0OKxdEhxeLokGJxdEixODqkWBwdUiyODikWR4cUi6ODisUeKhZ7qFjsoWKxh4rFHioWe6hY7KFisYeKxR4qFnuoWBygYnGAisUBKhYHqFgcoGJxgIrFASoWB6hYHKBicYCKxREqFkeoWByhYnGEisURKhZHqFgM1XcXofruIlTfXYTqu4tQfXcRqu8uQvXdRai+uwjVdxeh+u4iVN9dhOq7i1B9dxGq7y5C9d1FqL67CNV3F6H67iJU312E6ruLUH13EarvLkL13UWovrsI1XcXofruIlTfXYTqu4tQfXcRqu8uQvXdRai+uwjVdxeh+u4iVN9dhOq7i1B9dxGq7y5C9d1FqL67CNV3F6H67iJU312E6ruLUH13EarvLkL13UWovrsI1XcXofruIlTfXYTqu4tQfXcRqu8uQvXdRai+uwjVdxeh+u4iVN9dhOq7i1B9dxGq7y5C9d1FqL47guq7I6i+O4LquyOovjtySLGYoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Iqu+OoPruCKrvjqD67giq746g+u4Yqu+OofruGKrvjqH67tghxWKG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bqu2OovjuG6rtjqL47huq7Y6i+O4bquxOovjuB6rsTqL47geq7E4cUiwWq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqD67gSq706g+u4Equ9OoPruBKrvTqH67hSq706h+u4Uqu9OHVIsVqi+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O4Xqu1OovjuF6rtTqL47heq7U6i+O53beRKcXw6+/Zkf1UyNfoGiLGqI+VHN1OgX2C8jFTimezWFYXVMy7C6FNeDg/rC0ULh+2ARXY+NlAvH5pTWE9+NUPlginmBQeTTD0d/IpzbEnJNhN4Q9iIMhrAXYTSEvQjJEPYiTIawgpDzopnEySPCbNNJ5WD2MX8fzf4uZd4Q2nTSjdCmk26ENp10I2RD2ItQDGEvQjWEvQgtL+xGaItdnQiTs8WuboRWndQQklsRkncFhFaddCO06qQbIRnCCkL1y5lZIxcQWnVSRZh4QXibOgoIrTrpRmjVSTdCq066EVp10ovQW3XSjdCqk26EVp1UEYpbEQaqHO1D1iUT99G5UEBu1cx05GTIZyO3amk6cquujkYuqYLcqrHpyK16m47cqr3ZyINVh8cij479hlxKyK2anI7cqs/pyK36PBp5kDvksRr7ldYhCiq+djxzWvN+5pwLQ0o2pFcbUqueLzekVp1fbkit+r/ckNrqwuWG1FYvrjak0VZHLjektvpyuSG11Z3TDalbh1Rc4TXiaKtHP3tIV9YfQ1pT4ym59Rag5AsLgnN3jLYhnTGklvGebUg5bUOqjzttJLKM93JDahnv5YbUMt7LDan9EnP0kKZVdfQhVIfIr62Nt7+p0JhH9ssK/BDZLyXwQ2S/fMAPkdV1P3uI5G6IUqGfiq1Ogx8iq7vgh8jqqJ89RNt7pLchqh9fXZNkywDPNqQr74/SWAtDahnj5YbUMsyrDalYRnq5IbUM9nJDahnv5YbU3pW53JCSDenVhtR+3zvbkNZ+shX7PfByQ2qrR5cbUls9utyQ2urR1YZUrS49eEh92Lb+8VzosVCrG6cjJ0M+G7nVXdORW11URb42zLFyYbVArQ7pRmh5fzdCy7N7ESb7VbQbof0K2Y3QqqtuhFYtdSMkQ9iL0KqZboRWnXQjtOqkhjDz4iDnVGixyZYXdiO0vLBysLj1q0zifeFBzpYXdiO0vLAbIRnCXoSWF3YjtLywG6Hlhd0IbdW6E2F2ltTUEHqfV4TBFRBaUlNFSLoi/N1+QV8IyRD2IrSkphuhJTW9CO372f0IbaWmG6ElNd0ILampIlyPlvC7N7sej06BFtEpyPYOsF94k/GeytvSpbm8Lbeay9tWl+bytqWoubztbcupvO3T15N5WxU4l7eVjIfy9sJx3U9SWMJjiWkfvZ6PnAz5bORWaE5HbrXm0cjVb8hTCbml4wcjl22TAVFX+OXePrd6NHINW2BRkgJyS8qnI7e8fDpyy8unIydDfjDyJBvynArILS+fjtzy8unI7Weg6cjtl6DpyK36nI3cPn08H7lVnwcjT86tyJP3BeRWfU5HbtXndORkyA+O5Xfr5b//8Frh+LDtIfHxgWxfO545rQsKzDkXhtSq28sNqVXPlxtSq84vN6RW/V9uSG114WpDah8Ev96Q2urI5YbUVl9ON6TrUgOLK+yVwba687OHdGX9MaQ1NfVvyGf74PjphrTyfaFsHxy/3JDaB8evN6SW8V5uSMmG9OAh5btf1aWE3H4pmY7cfsmYjtx+aZiO3Oqi6citbpmNXK2umI7c8v7pyG0lejpyWymejpwM+WzkVn1OR27V58HIU9Rt2azwCbRsH2iej9yqz+nIrfqcjdw+GD0fuZVCByPP20s2kj8ce0BupdB05JYkHo1ctsBymyoLyG36PBa5+g25+hxrZ8/rm16S7z4V5ksH17ZTtS/2XmkwbcH5QoNp+duFBtMywwsNJtlgXmcwbWH/QoNp1eCFBtN+jLjQYNrPHBcaTFsBuspgBudsBehCg2krQBcaTFsButBg2grQhQaTbDCvM5i2AnShwbQVoAsNpq0AXWgwbQXoQoNpK0DXGUxvdebBgxn8qvr2N/9w/BdyyzmPRs5xQ55cAbllhh3IvxBaPtaN0LKgboSWe9QQBtYVYdKOoz+BB/uFaDJw+xVnMnDLgCcDt19DJgMnA34kcJ9k21Py9jcVkFuNNx251XjTkVtNOB251ZDTkVvNORt5tKpzOnKrO6cjt8pzOnKrPacjJ0M+G7lVn9ORW/U5HblVn9ORW/U5HblVn7ORk1Wf05Fb9XkwcvW8Ilf2BeRWfU5HbtXndORkyGcjt+pzOnKrPqcjt+pzOnKrPqcjt+pzNnK26nM6cqs+pyO36nM6cksSD0aeXF6RJ19oV2GbPg9Gnu/u8hwLd7kAT59+Pdj7uyf0CXK3tkK5O4qRv/0EnrMO9RN4ojjUT+C1wX1+Rrf4Sa7gJ72Jn8CrYIf6CZxV7PNTVj+15Cfwes+hfgIvshzpJ/Kni/f5mZYkVO5UbH5e5flMusyf+X5XjdXPqzyfWZZUO2ss+HmV57PmJ3DpdKSfyF/HbPUzhYKfV6lXan5epV7J4lc/teDnVebPzPzST3oTP69Sr9T8vEo+5J1z6zqbSwVPL5MRZXrtaHdKlMNyhZi5SmVdC43itkzUSyx5GtK6YBnvj84lLhrTIlrJbe9JptKp1adFiIbgXx/svdvewfS3qv3+8C+K+U0pyqJa/V2huGDp/0jqNbF4w1LCEgxLCUs0LCUsZFhKWNiwlLDIdbDohuXuJ+Iilqy8ZX8blcDf2V//pwKvieVCSfGRWC6U5R6HxbsLZblHYrlQlnsklgtluUdi6c9y1539b4RiZcFFw/KDWFDhivREcV0Vu1sW+84tvKNd0r9suMFGGmx6J/ib0nUt+/Z3kkf30/hL5OGX8G78Jfz4S8T9t0jol3X3DQEXMj3I6t4m+A9cIo6/BI2/BI+/hIy/hDbchanBJu+32bk73peNb7AJDTYNT+/OHaK+bBomn9gw+cSG+yA23Aex4T6ghvuAGu4DargPqOE+oIb7gBruA2q4D6jhPqCG+4Aa7gNuuA+44T7ghvuAG+4D7p2kkl9eiUv3m41ELRzL649onOIPx35pYSAtMlGL+PX1ySgFLQqkJQFpyThaulthjtTigbQEIC1xppawaeGCFgLSwkBaBEgLUNwVoLgrQHFXgeKuAsVdBYq7GoG0TM1389aGqAUtDKRFgLQokJYEpCXjaEkOSIsH0hKAtEyNuyyLFg0FLQSkhYG0CJAWBdKSgLR0x12nq5bCc9r92nPt/H7w+cPg88fB56fB5+fB55fB5+9+KUDWPj5//4Qti9Dd789VL5DHXiB0v9NVvYAffYEw+gJx9AVo9AV49AVk9AV09AXS6AuMfpL96CfZj36S/egn2Y9+kv3oJ9kPfJIfDyYJy2tYtz8rLz7eZuCwTsaPbw/eVl+nSidaUgMilpp0x6v0H5skv6SPjj5+dPTxo6NP6C8F1j3+krvbPnC9gB99gTD6AnH0BWj0BXj0BWT0BXT0BdLoC+TBF4ijn+Q4+kmOo5/kOPpJjqOf5Dj6SY6jn+Q4+kmOo5/kOPpJptFPMo1+kmn0k0yjn2Qa/STT6CeZRj/JNPpJptFPMo1+knn0k8yjn2Qe/STz6CeZRz/JPPpJ5tFPMo9+knn0k8yjn2QZ/STL6CdZRj/JMvpJltFPsox+kmX0kyyjn2QZ/STL6CdZRz/JOvpJ1tFPso5+knX0k6yjn2Qd/STr6CdZRz/JOvpJTqOf5DT6SU6jn+Q0+klOo5/kNPpJTqOf5DT6SU6jn+Q0+knOo5/kPPpJzqOf5Dz6Sc6jn+Q8+knOo5/kPPpJzqOf5Nz/JOfl2OSl9uOz98vBt7+2g4P3n3Kic1hyPJacMFfO9s1Af7dpyoec0nsFfPdiAcuP3xj8kh/PLZ/OLZ/PLV/OLV/PLT+dW34+tXzvzi3fn1v+uWddf+5Zt/tN3KHyZe1b+fg7FeRDz7p1+dCzbl0+9KwrMW/y7762usmHnnXr8qFn3ar8AD3r1uVDz7p1+dCzbl0+9Kxbl48961blY8+6VfnYs25V/rln3XDuWTece9aN555147ln3XjuWTeee9Y9oFtkoPyksspPqgX50LNuXT70rFuXDz3r1uVDz7p1+dCzblU+Qc+6dfnQs25dPvSsW5cPPevW5Z971qVzz7p07lmXzj3rMna5InFLmJUL8rEf3bzRzz4U5EM/ujluv65koYJ86JStLh86ZavKF+iUrS4fOvLkvMpXFwuRR6BTtrp86JStLh867tflY8f9qnzolK0uHzplq8vHnnWr8rFn3e2jvzdXCtOWYs+6VfnYs25VPvasW5WPPetW5WPPulX52LNuVT72rFuVjz3rVuVjz7pV+eeeddO5Z9107mkrIU9b6ugu45T8g/yCFArLolwipcrRcf0sB4W73+ulcOjHRxy+j/3YAPv+4C+IyJPnaSAiT+GngYicSJwGInI6cxqIyEnVaSAip3ZngZiRE8zTQEReXDoNRORa4TQQrWI5ACIZxH6IVrEcANEqlgMgWsVyAESrWA6AaBVLN0RyVrEcANEqlgMgWsVyAESrWA6ASAaxH6JVLAdAtIrlAIhWsRwA0SqWAyBaxdIPEXoXy9NAtIrlAIhkEOsQQ9wgEj9CtNn5D0BUv+z5EjTGR4g2Ox8A0WbnfojQu12eBqLNzgdAtPXEAyDaeuIBEMkg9kO09cQDINp64gEQ51YsNw0Llej0B4hfchKWnAwlZ/I+sFU5HktOwJITseR0z9tx3ao1RebXBzPTcmJm3sJOiqUzs3fLmTno/cFf0rtny6h+lZ6kIl1dWqSr15p0Dav0lB6ld89Rt1xhnRioQp1onXRux0pFenTrmWPwj9K7Z4Zb/NyGtXb/psxry2XKejdI5Wlt5R5S3GbXrCUhQuvkKtlVJle6PXcLxBS2hdIY6RtMMjBlMNnAFMH07yR7VTDewJTBBANTBhMNTBkMGZgyGDYwZTBiYMpgLPN9AsYy3ydgLPMtg2HLfJ+Ascz3CRjLfJ+Ascz3CRi6Dph1d/z0w481WK8K8oUy6nMAv1Cmfg7gF6oAzgH8QpXFOYBfqGI5BXC5UCV0DuAXqrDOAfxClds5gF+oIjwHcDLgc4FbpTkZuFWak4FbpTkZuFWak4FbpTkXuFqlORm4VZqTgVulORm4VZqTgZMBnwvcKs3JwK3SnAzcKs3JwK3SnAzcKs25wJNVmpOBW6U5GbhVmpOBW1o4d8vCZJPm3B1Xsk2ak4HbpDkZuE2ak4Hb8uxk4GTA5wK35dnJwC0PnwzclmcnA7fl2cnA51aa2W0bdman/jVwvdtr725V4nv3PHZusnanm/ZUuVl85uzWw4X19eHHtt+y84bmGZpgaJ6hiYbmGRoyNM/QsKF5hkYMzTM0amieoUmG5hmabGieoPGWDT9FY9nwUzSWDT9F8ybZ8Jez9E7OvknG+uXspXLQM7wvw/5Sue05kF8qZz4H8kvl4qdAHi6V458D+aVqh3Mgv1RNcg7kl6p1zoGcDPls5Jeq+86B3KrP6cit+pyO3KrP6cit+pyNPFr1OR25VZ/TkVv1OR25VZ/TkZMhn43cqs/pyK36nI7cqs/pyK36nI7cqs/ZyMmqz+nIrfqcjtyqz+nIrfqcjtzy8sORv95SiskylsORv+6tZraMZTpyy1imI7eMZTpyy1imIydDPhu5rZdPR255+XTktl4+Hbmtl09HPrv6zGFl6MW/ZhicyqreZTe3zVicoXmGxhuaZ2iCoXmGJhqaZ2jI0DxDw4bmGRoxNM/QqKF5hiYZmmdoLBt+hkYtG36KxrLhp2gsG36KxrLhp2jI0DxDc6ls+BTvxOilsuxzIL9U9n4O5JeqCs6B/FLVximQp0tVMedAfqnq6BzIL1V1nQP5paq5cyAnQz4buVWf05Fb9TkduVWf05Fb9TkduVWfs5Fnqz6nI7fqczpyqz6nI7fqczpyMuSzkVv1OR25VZ/TkVv1OR25VZ/TkVv1ORm5OKs+pyO36nM6cqs+pyO3vPxw5K83jRJnGcvhyF93SouzjGU2cm8Zy3TklrFMR24Zy3Tktl4+HTkZ8tnILS+fjtzWy6cjt/Xy6ci7q09Oy1ZaSUJ6fXDwMS3SgydPrxlGF5YBii5uwFP8Fp9PLL7/O/M/U7w/s/hwZvHxzOLpzOL5zOLlzOL1zOLPPMOGM8+w8cwzbDzzDBvPPMPGM8+w/d8c/ZnizzzDxjPPsPHMM2w88wwbzzzDEvYMu67ARO/To3jsGbYiHnuGrYjHnmEr4rFn2Ip47Bm2Ih57hq2Ix55hK+KxZ9iKeOwZ9rV4Bp9h/Sqe4r34x4NzTsvB3rm7dw9XV8Hn4yNdBZ+9j3QVfK4/0lV6H1fB84gjXYXOOvzmanDptavexXUD29vf6h59hU5SvIbN11zzlZhXXykXZlbonOZgX6FToGN9FeiM6WBfoVOmg32FzpkO9hU6aTrYV3ojX6HTpoN9xc6bjvX1jfImeaO8Sd4ob9I3ypv0jfImfaO8SU+aN32JpzOLP2lm8yUeekoLabnpY6wv8eSY1kckS3z0FXpKO9bXBD2lHewr9JR2sK/QU9rBvk6eFYTi6uttPfje1y89DKZHwPQomJ7uue22arHqyeH1wZHXBrwobtvsxEvx7t8eFR/vj85UOFpjWkQrOXr9YKlPixANd52A5afw9mvIcurb3x+P9e+fwvymFGXZu0Z94fei/l2wr4nFG5YSlmBYSliiYSlhIcNSwsKGpYRFroNFNyy+siSWdVsQc3dbATB/Y1HDUsJyoaT4SCwXynKPw6LuQlnukVgulOUeieVCWe6RWLqzXF1XOlJysYJl3eaW3EYwKn2LISQxjCRGkMQokpiEJCYDienf2/VIMR5JTEASgxSBPVIE9kgR2CNFYI8UgT1SBPZIETggReCAFIEDUgQOSBE4IEXggBSBA1IEDkgROCBF4IAUgSNSBI5IETgiReCIFIEjUgSOSBE4IkXgiBSBI1IEjkgRmJAiMCFFYEKKwIQUgQkpAhNSBCakCExIEZiQIjAhRWBGisCMFIEZKQIzUgRmpAjMSBGYkSIwI0VgRorAjBSBBSkCC1IEFqQILEgRWJAisCBFYEGKwIIUgQUpAgtSBFakCKxIEViRIrAiRWBFisCKFIEVKQIrUgRWpAisSBE4IUXghBSBE1IETkgROCFF4IQUgRNSBE5IETghReCEFIEzUgTOSBE4I0XgjBSBM1IEzkgROCNF4IwUgTNSBM6HRmCt7PuSKKw9YsSbcuWScrfuMRSd1Bqt86ribjP84P2nm8k5YDdffqwsOX9e6eG80uN5pdN5pfN5pct5pet5pafzSkeeeV9L98iz6csPkyWPPJtWpCPPphXpyLNpRTrybFqRjjybVqQjz6YV6cizaUU68mxakY48m76WHqBn0+M+SZcC9Nx7pKPQM/WRjkLP60c6Su/iKHTOcKSjwBnGoV/HTAE4ITn0OyopAOcvB3sKnO4c62kEzo4O9hQ4PTrYU+D86GBPgROkgz2lt/EUOEU62FPkHOlYT98mR4pvkyPFt8mR6G1yJHqbHIneJkeiU+ZIX9LpvNJPmcV8SQeewg79il4i4CnsWE8ZeAo72FPgKexgT4GnsIM9RZkHvtSghPYvNShF5JeauYUe52UmS+Ldo5oEpSYjqREHpaY3anvHsv0ixenhY52pe6+PP3CJOP4SNP4SPP4S+8LEl01qsMn7bXbu1fBl4xtsQoNNbLChBhtusJEGm4b7QBvuA224D1LDfZAa7oPUcB+khvsgNdwHqeE+SA33QWq4D1LDfZAa7oPccB/khvsgN9wHueE+yA33QW64D3LDfZAb7oPccB/k/fdBdq7BxjfYhAab2GBDDTbcYCMNNtpgkxpsGu6D7u6MdfVNt9YPXk7uR548jDx5HHlyGnlyHnlyGXlyHXnyNPLkeeDJw8gnNIx8QsPIJzSMfELDyCc0jHxCw8gnNIx8QsPIJzSMfEL739sK6wdub+vgtfWI2zy/HO1vEfnucCkcHpxK/j789vuY09eH3xYZlheEb/X5tiQa1JcXUNejSalydOTlYAp3X88tqo5uOTZET/cHfyEnQz4bORvy2cjFkM9GroZ8NvJkyGcjz4Z8MvL+1y4N+e9Vh9XHG31+RO4N+WzkwZDPRm7V53TkZMhnI7fqczpyqz6nI7fqczpyqz6nI7fqczZytlJoOvLZ06fTFbm7e0u1yNBnzm49XPgaayyshnw28mTIZyPPhnwycnGGfDZyb8hnIw+GfDbyaMgn5+X934I25HuRsyGfjdyqz+nIrfqcjtyqz+nIrfqcjVyt+pyO3KrP6cit+pyOnAz5bORzp8+Ut/0UU9YK8qBrm9PHjqjrwVnPu8KSnAGfC9wb8LnAgwGfCzwa8LnAyYDPBc4GfC5wMeBT8/CkBnwu8GTA5wK3SnMu8GyV5mTgVmlOBm6V5mTgVmlOBk4GfC5wqzQnA7fCZybw6Fz3pOny+mmCH3qpisA908Lb5zs3fclNr47Wn+TUScZcH7lBjAaxHyIZxH6IbBD7IYpB7IeoBrEfYjKI/RCzQezOE7t34jeIN4jeIPZDtIrlAIhWsRwAkQxiP0SrWA6AaBXLARCtYjkAolUs/RCDJdsHQEROcUTy+hluuRH9AcuXfDq3fORp/Q/IR55Q/4B85KlMNOomn6QgH3kS+QPykRec6vIj8uzzB+QjL7L8AfnIyxt/QD70rFuXDz3rqqdNfizE/Qg969blQ8+6dfnYs25VPvasW5WPPevW5BP2rFuVjz3rVuVjz7pV+dizblX+uWddOvesS9izLudNvrqCfOy4X5PP2HG/Kh867qdtSxdJxAX50HG/Lh867tflQ8f9unzouF+XDx336/Khq626fOhqqy4fe9ZNvMkvLZAL9qxblY9dbVXlY1dbVfnY1VZVPvSsW5ePXW1V5WNXW1X52GucVfnYa5xV+eeedfXcs65i17oqm3zVgnzsWrcqH7vWrcqHnnXr8rFr3bzJzz4U5GPXulX52LVuVT52rVuVDz3rVuUn7GmrKr83cEaWZTEjplw5OLD33wcHjmk7mIq+rgff3PY/aH88+ubq98FypyJG/vaTL+KnpuUG0MwFP+Uqfq5zpmYp+Klv4md6Ez/ze/jZvVHgWfz0b+JneBM/4+X8TK4wf3ZvAncWPy+TDymv2bMr+HmZfEjySz8vkw9V/LxKPpTCksenWKhX8lXyodd+eneVfKjm51XyoZQXP7NzBT+vkg/V/LxKPlTzk97Ez6vkQynJ6mcpDl0lH6r5eZV8qObnZfKhip+XyYde++kvkw9V/LxMPlTx8zL50OZnoS7z/jL50PqeSvZc8JOu4qeml35eJh+q+HmZfKjiJ/D86bbftF2q7eUv6xcIRLY3aSLlwrE5rTu5OJ8rB0vgxUEJqXZqn26/2y8nTz8sVd2O/0QegKfykyKn7XsSiWMBOXBWcVXkwAnOVZED51pXRU6GfDZy4Az0qsiBk+GrIgdep7wAcgkF5MBLpmdFThty5drZbwtly9mz387uSwffflZdf1cNd6Ppl8G0uvY6gxmtYr7QYFotfqHBtCr/QoNp6wcXGkyywbzOYNqax4UG01ZTDh7MHNYfRG9/y2NpH60aPPr5yduvnD+8OLkgJ8sMj77L/baAle/fJV+R2ywx/S63WD4ylscSclsZn47cVsanI7eMZTZytlXmo5HHrcjKRAXkthY8Hbnl5dOR27rqdORkyGcjt+pzOnKrPqcjt+pz9rIWW/U5HblVn7ORi1Wf05Fb9TkduVWf05Fb9TkdORny2cit+pyO3KrP6cit+pyO3KrP6cit+pyNXC0vryH369E3+q6GXENcT66BCh2eann5dORkyA9GLnFDrrmA3PLyg5FHt366R2Mo9DGr5eXTkVtePh255eXTkVtePht5sl+FpiO3X4WmI7fq82jkdIecuYDcqs/pyMmQz0Zu1ed05FZ9Ho083iMvdDcjf/P0qsit+pyO3KrP2ciRP0p7VeRWfU5HbtXndORWfR6NPLkNeSr8EIf8AeOrIrfqczpyqz6nI7fq82jkeoc8F3aqQP7Y9VWRW/U5GXlA/gT4VZFb9TkduVWf05Fb9TkdORnyY5GTX1UrhVhAbtXndORWfU5HbtXndORWfR6N3N0jpwJyqz5nI/dWfU5HbtXndORWfU5HbtXndORkyGcjt+rzYOQhba22FGtfLPIU/Xo8lbougrdq9WcPUeRtiNhXj0+8iqekqTCkVg3/7CHdvKQoherZW/WM9NQVh8iqbfQhCladww+RVfPwQ2TV/88eIpVtiHLozwCDrS787CHN21N3K5MLQ0Q2RDhPXXmIbPUCfohs9QJ+iGw1An6IbDXiJw8Red2GKMYDMkBbvfjZQxrvnjp63CMjRFu9QHrqikNkqxfwQ2SrF/BDZKsR8ENENkQHDxHf7YmdCs0Q0VYXpiO31YLpyK36n47cqvnpyK3ano2crHqejtyq4enIrbqdjtyq1enIyZDPRm7V53TkVn1OR255+bHIJa88bn8XPvV2O4chPxh53rZVca7QwsOWl09Hbnn5dOSWl09HToZ8NnLLy6cjt7x8OnL7VWg6cvtVaDpyqz5nIxerPqcjt+pzOnKrPqcjt7y8cjCJLjBIkhYQWp5dRRjThrDQ1SGWN3cjtDy4G6Hltb0I1fLUboSWd3YjtDyyG6H9KtGNkAxhL0KrTroRWnXSjdCqk26EVp10I7TqpBdhsuqkhlDdcmbSWNhSJVl10o3QqpNuhFaddCMkQ9iL0KqTboRWnXQjtOqkG6FVJ90IrTrpRZitOulGaNVJN0KrTroRzs0L3boJVrgXf0P4pWZuiuVoHVBH8qhmbrbi2K1qVB/VJCg1GUhNdA5KjYdSE6DURCg1NFdN3NRQQQ1DqREoNQqlJkGpyUhqJn+uuabGQ6kJUGoilBqoWDz5q6kuL0l98HdfB1jVzI3Ft4plVRPkUY1CqUlQajKSmskf56up8VBqApSaybE46RZv+FENQalhKDUCpUah1CQoNRlJzeRPjdTUeCg1AUoNVCye/FkAT5sajo9q5sZiz5uaFB7VCJQahVKToNRkJDWTN66uqfFQaibnxesnum7CHivfyTsB19QQlBqGUiNQahRKTYJSk5HUTN6stKbGQ6mBisWTd3+8LdEuam6J8aOaubH4lhivauhx1py8Z2BNjUCpUSg1CUpNRlIzeeuumprJsTiHLd74RzUBSk2EUkNQahhKjUCpUSg1CUpNRlIzeXuamhqoWDx505QgWyaqj5no5P1Hgm6zZn58c2HyVh41NQylRqDUKJSaBKUmI6mZ3IwfeIt++hj9Jve119QEKDURSg1BqWEoNQKlRqHUJCg1GUlNhorFk7v4ol/fIovh8V2ByQ1xMeRVTeFdgRyh1BCUGoZSI1BqFEpNglIzNxZHp1u8eXhrlSb33dXUeCg1AUpNhFJDUGoYSo1AqVEoNQlKDVQsntx3F7cVk9uCxKOaybE48aKGSmwClJoIpYag1DCUGoFSo1BqJsfi7TeY+PjWKk3uu6uomdx3V1PjodQEKDURSg1BqWEoNQKlRqHUQMXiyX13tHUs0eNbqzS57454XaElzY9qPJSaAKUmQqkhKDUMpUag1MyNxbS9JU/Mj2oSlJqMpGZy311NjYdSE6DURCg1BKWGodQIlBqoWExQsZigYnF3/5QXWV6N8KKhcrDmZTXJp7s9br0v7Z4bnVt2Zo0+1I5OkhdPk8baXrvpVkkuR5NS5egb8u+Db4s627FSXqBfgUdP9wd/AWcDPhe4GPC5wNWAzwWeDPhc4NmATwXe3ZFqwHcC9wb8WOBh62WLd/t7rcCDAZ8LPBrwucDJgM8FbpXmZOBWaU4GbpXmZOBWaU4GbpXmXOBqleZk4Fb4zAVe7tTXtcFVZQMebr8YfRnFFiNqMeIWo2LmpWsTnUr4wahwY3ha7jjvJVWOZl0O5ry9ieLztxqFUpOg1GQkNeUu8p+mpvi8yPo46903gT72Q/oy4hYjaTEqDp1X0SU2eVV3t23KV8DhcnvoH7DzjXah0S422lGjXTFMsI/LDMX+Ltal+G2VWqzKDTVVK2myyi1W5WaJqpVvsgpNVrHJinZa9WY4LvAakVzI9KiI4RQJnCKFU5TgFGU0RdHNVRRU11Q7xW1C/9g7rFAe0JrwS3aVhP+Wpi+ib8n33Se7I3376t/I1/BGvsYL+ery6msIBV/pjXzlN/JV3shXfSNf0xv5mt/HV7pS3lTz9Up5U81X7LwJY7nc523TXx/uD/5iiJ2PnYMhGcNuhtj54zkYYuel52CIne+egyF2Hn0Ohtj5+SkYMnbefw6G2PXEORhandLP0OqUfoZkDLsZWp3Sz9DqlH6GVqf0M7Q6pZ+h1SndDMXqlH6GVqf0M7Q6pZ+h1Sn9DMkYdjO0OqWfodUp/QytTulnaHVKP0OrU7oZqtUp/QwtP/wDLb5xY0j8yNDm5TpD9esnNn+QsTC0ebmfoc3L/QxtXu5mmGxe7mdo64f9DG39sJ+h5Yf9DMkYdjO09cNuhtnm5d6dmjnbvNzP0OblfoY2L/cztHm5n6HNy/0Mbf2wn6GtH/ZuVcnZ1g/7Gdr6YS9DcVan9DO0OqWfodUp/QytTulnSMawm6HVKf0MrU7pZ2g5djdDPzm3qe6EKj7AKYpwighOEdrOzOLRdmYWf6H9FtWte8Gqf9wLVvyF9lus+nqh/RZrvoYL7bdY9fVC+y1Wfb3QPtVVXy+0T3XVV3ojXy+0T3XV1wvtU1319Y3ypvBGeVN4o7zpSt/3qPr6RnnTlb7vUfX1jfKmK30HQrOuvuZU8PV9vhcgp/1ewJf6s0bWL/VnjZVf6u3X194OabHd9A9gaL++9jO0X1/7Gdpbov0M7Rfsfob2lmg3Q9tN/wCG9pZoP0N7S7SfodUp/QzJGHYztDqln6HVKf0MrU7pZ2h1Sj9Dq1O6Gdpu+gcwtDqln6HVKf0MrU7pZ0jGsJuh1Sn9DK1O6WdodUo/Q6tT+hlandLN0HbTP4Ch1Sn9DMkYdn6RQGw3/e7dUsV20z+Aoc3L3QxtN/0DGNq83M/Q1g/7Gdr6YT9DMobdDG39sJ+hrR92M7Td9Lt3PhbbTf8AhjYv9zO0ebmfoc3L/QxtXu5naOuH/Qxt/bB7p0/bTb+bodpu+gcwtDqln6HVKf0MrU7pZ0jGsJuh1Sn9DK1O6WdodUo/Q8uxuxn6K+2o93rnNfUX2lEv+fUWSMEXfKUL+RrW3QNTpIKvF9qJuOrrhXZKrPp6oZ2Iq75eaCfiqq9X2gGz4uuVvuBQ9fVCOxFXdjbVK33BoerrlfKmmq/0Rr5eKW+q+XqlvKnm65XyppqvV8qbar6+z87heqUvOFR9faO86UpfcKj6ivaVRo1oX2nUqHCKEpyijKZo9ncd/oCioTH06xJh/CXi+EvQ+yxIgG/ef6yvb7QwDL4Z/rG+vtHCMPjm8of6Cr4J/LG+XqnAqfl6pQKn5uuVFoZrvtIb+fpGeRP4pt+HLkiAb859rK9vtDAMvtn1ob6Cb0p9rK9vtDAMvsnzsb6+0Q/q4JsmH+vrG/2gDr4J8bG+vlHeBL6p77G+vlHeBL5J7rG+WtNr72a2N4+MYTdDa3rtZ0jGsJuhNb32M7Sm136G1vTaz9A25+lnaI3D3Qxtc+8DGFqd0s/Q6pR+hlan9DMkY9jN0OqUfoZWp/QztDqln6HVKf0MrU7pZpitTulnaHVKP0OrU/oZWp3Sz5CMYTdDq1P6GVqd0s/Q6pR+hlan9DO0OqWXYbIN0rs/Hp1sY+ruD9sl25j6AIY2p/QztDmlm6G3ta9+hrb21c/Q1r76GVp+2M+QjGE3Q1v76mf4JD8MYWMY7hl+WeUWq2cbkFes7Enp/YxmAt9e+RwMraLvZ2gVfT9Dq+j7GVpF380QfFvsczC0ir73s3EJfBvvczC0ir6fIRnDboZWp/QztDqln6HVKf0MrU7pZ2h1SjdDsjqln6Hl2P0MuWX1+8me+6sPHPTxSnm/zZM94F/b+Aab0GATG2yowYYbbKTBRhtsGu4DbrgPnuxpK26xuXvOVxvfYBMabMr3wfoyoxTeZXyy5+drG26wkQYbbbBJDTZ5v82TPfpe2/gGm9Bg03AfaMN9oA33QbnnufYrbLnL9zZlrl+akvT4PJT7WqtWucWq3LtYtfJNVsV7wqsugctrfpxfyx1ZVStqsuImK2my0iar1GSVG6yyc01WvskqNFnFJitqsuImK2my0iar1GRVvjeyX9P6HB6tyu99Vq18k1VosSq/G+HdGrG9k/RoJU1W5fHycY2Hnv2jVWqyyi1W5V/1qla+yao8Xl54tUqPDMvrm57ckjre/ixcS5usUpNVbrEqr1N4DitDZvdo5ZusQpNVbLKiJituspImK22ySk1WucWKm+4NfnJvrGsrnnN4tApNVrHJipqsuMlKmqy0ySq1WJVrbx+3+SvGx7hRrr6rVqHJKjZZUZMVN1lJk5U2WaUmq9xipU33hjbdG/rk3iBdreQx2mhssqImK26ykiYrbbJKTVa5xaq8/2kt3yjv+Fm1Ck1WscmqSD6tKfaPH9HTb6PUYpQbjMpLIjUj32IUWoxiixG1GBWfxuR0NdKCkbQY5d1Gt3vMtRj5fUaFn468LguF0adtze/2j+9LhPGXiOMvQeMvoS0DmFqMWu4v33J/ed9iJC1GLfR8Cz3fQi+00Ast9EJoMdo5nTze3pzWH3jvb+71AnnwBaLrvYD4ZZqWKIUL+NEXCKMvEEdfgEZfgEdfQEZfQLsvELYLcOECafQF8uALkBt9AT/6AqOfZBr9JNPoJ5lGP8k0+kkmHX2BNPoC/XNyTssFXCGrYDf6An70BcLoC8TRF6DRF+DRF5DRF9DRF+h/ktcXNO9fKt0ukAdfQNzoC/jRFwijLxBHX4BGX2D/AtfNqKVYl5ZiXVqKdWkp1rWlWNeWYl1binXdGXG/jKTFSFuMUotRbjBKrsXItxiFFqPYMLiJWoxanqfU8jylnc9TwzpoduMvMX7ZO49f9s4t8Tq3xOvccn/llvur5acP76jFiFuMpMVIW4xSi1ELvZaFfV9eo3+9RuvLa/Q1oyKI16WtL6/RV4zKa/Q1I99iFFqMYosRtRg96Qh4VeT4JxtHVYy0xSi1GOUGoyebv1SMfItR+Y54mbD78oJ+zYhajLjFSFqMtMUoNRg9eTvUufW9XHf3HrX/2Nfm4Wii9Z0VIt4epWJvaIrrqVMMPzSSfgkqvz7i1vh4C9VhqiAqCyK/EpIaIc+yHi1eXwvKMS8HZ7pLqVdBXBPk3Y+CvsykzUybzJ6tNPDyFmvymh5ce7Z8ULGiJituspImK22ySk1WucXqSbVfsSoXd7I2R6u7a7r2/tuIWoy4xUhajLTFKLUY5QajcmFYM/ItRqHFqOWOyA13RHjSiSZbV46EzYz126o8vQit/VBy99blakVNVqlJYW6x8k00nvRe1axCk1VssqImK26ykiYrbbJqujd8070Rmu6N4Fvu+RCarJqeytD0VD7pAaxZSZOVNlmlJqvcYvWkB7Bm1XRvxKZ7I7bcG5GfTCluSVsl3+XhPpcKg0DL0mMKd9u13A7+ugSPv4SMv4SOv0Qaf4k8/BLixl/Cj79E2HmJL6vYZEVNVuW7ReK6Wid3fUyRFrPcZFaue+pmvs0stJnFNjNqM+M2M2kz0zaztrtE2+6S1HaXpLa7JLXdJantLkltd0lqu0uelORK2yqluoJZcdzUeVpLxPs1/MWsXCzXzXybWWgzexJcc35tlspXW5c+1WlhAHJuMSPn2sx8m1nZt+hWkjFIwSw3mZVr57qZbzMr3yVx3V9RbzlZwSy2mVGbGbeZSdXsLidZzcKTAUibWU4FM99mFtrMYpsZtZmVSd5Ot5jR3d5iq1m5MKublUUmXjI1TVIy0/LVJK1Xk1wwS21mucms3Emh4tcBkFC4lcv9EXWz0GYW28yozYzbzKTNTJvMyu/NK6f1Vr7fV2MzK5PUHNdbuZCXUHm9oG7GTQ9Oua6vm2mbWWozy01m5Tq5bubbzEKbWWwza4uT0naXSNtdIm13idbjZOkJUN9mFtrMYpvZkzi57k2pooVJuFwt3gqUlaTefehnNStXi3Uz32YW2syekMy6mXHBjNrMuM1M2sy0zSy1meUmsyfVoq6/uN/+LIxbrs9v/senu/A6ym08lqTp9nfp1s9PIp2Xl/Nh+W3c6jRafh+3bqZtZqnNLLeY8ZPKuWYWB29GwHHwZgRMgzcjYPKjLxBGXyCOvgCNvgCPvoCMvsDgxkfub2GuXWBwCzOPbmHm0S3MPLqFmUe3MHN/C/PrN4G5v4W5dgEZfQEdfYE0+gKDW5h5dAszS0MDKEtoMeIWI2kxamgo4pb2WW5pn+WW9lnW2GKUWoxa6KUWeqmFXmqh19LUyi1NrVz+BTMkXar7kNLd76XfXZFc/gWzbhbazGKbGdXNtGDGbWblr7WktH6tJd3/ELOaaZtZajPLLWbiXM0s3zVpbGa+yezJu8a6Lino3c8wkb+NfItRaDGKLUble9Gtn3lzsWDELUbSYFT+8TGE9ZYPoWBUvFLUZXRjLhmllivlBqPyq6c1ozKI9auA8W5v4c2IakZcMOIWI2kx0haj1GBUXpKpGfkWo+KTG+PyEMa7bxhsRrHFiFqMuMVIWoy0xSi1GOWaUSHulUv7mpEvGy2ZTJSSUfmOCPzSKLYYUUPcK5e/NaOWCKtPXm5aX/ei3380jqSc2mZaJo3M/GgTGmxigw012DR8iOlmJU1W2mSVmqxyi9WTD+7VrHyTVWiyik1W1GTVdG/kpnsjN90bueneyC33hj55g/JVtNDybvN5fTExh4LN/idfyxvBVK6jDTapwSbvtykXNq8ZeN9gExpsGsbHU4MNN9hIg035PuDlvs4aHm1Sg03eb1N+H7Vi4xtsQoNNbLCp3Qclm4b7IDTcB+UWyYpNarDJ+21iQzyIDfEgNsSD2BAPYkM8iA33QWy4D2LDfRAb7oO48z74n9u//u+f/v7bn/7lL3/+z5vFx3/8r7/+6z9++9tfv//5j//3H8t/+Ze///aXv/z27//8H3//27/++d/+6+9//ue//O1fP/7bL+77f/4XsedfiaPc1HwM4a2IyL+SSP5Q9/HvEOVXCtnf/s2f/87hV4r0cfzn/BRJ+ddIyX38H/7zDOpuZ9Bw03rT+/8B","brillig_names":["public_dispatch"]},{"name":"_approve_bridge_and_exit_input_asset_to_L1","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"token","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"9283123155612446889":{"error_kind":"string","string":"Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["_approve_bridge_and_exit_input_asset_to_L1"]},{"name":"swap_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"input_asset","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"input_asset_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"input_amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"private"},{"name":"output_asset_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce_for_transfer_to_public_approval","type":{"kind":"field"},"visibility":"private"},{"name":"uniswap_fee_tier","type":{"kind":"field"},"visibility":"private"},{"name":"minimum_output_amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"private"},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_L1","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"1186437190978851533":{"error_kind":"string","string":"Non-zero hint for zero hash"},"1589673740894288059":{"error_kind":"string","string":"Hint values do not match hash"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"7952883935970497419":{"error_kind":"string","string":"L1 portal address of output_asset's bridge is 0"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16275222249430394394":{"error_kind":"string","string":"input_asset address is not the same as seen in the bridge contract"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17695220409134080280":{"error_kind":"string","string":"L1 portal address of input_asset's bridge is 0"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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jb+dO34L7PhrWX9dvd397PX2airtNteq6N1Ua5vtkKwNtGr57tVfMyOemU5m1DPTyUycNjNR18zYVmbMM9PJDPtG45WZYXftn5mZ9JaZIhuZYbfAr8wMvJ98YWbgnepn7tp3mdHHzKR5e+D1Tk615Y3MzNsD72Vm3h54LzPz9sB3OtM2+plkF8pMzW/fD8S0k5rPM660rTmPYc+LimuBJEb5OeMqXaltn76YV7rTgBTzZZZyutLN0fTFvNL93LBifk0N/YYurV89tJj3Gi27vXW5nwV1a+JqXaPWWuUujq+JyfT7uZclhn4797LE0O/mXpYY+s3cyxJjnpjtxNDvi16WGPo9xssSQ+/XX5YYeu/7ssR457udmOKdbycx3vl2EuOdbycx3vl2EmOemO3EeOfbSYx3vp3EeOfbSYx3vp3EeOe7nZjqnW8nMd75dhLjnW8nMd75dhJjnpjtxHjn20mMd76dxHjn20mMd76dxHjnu52Y5p1vJzHe+XYS451vJzHe+XYSY56Y7cR459tJjHe+ncR459tJjHe+ncR457uZGAne+XYSc6XO9+1aaw3fJebrtV6pmd271iv1py3f/U6W7Mx4K+V2jVbDXWom+Z2sJYVe+llLf6V7DC/9h0p/pbsoL/2HSn+l+0Qv/YdKf6U7YS/9h0p/pXt9L/1HSi9XcjO89B8q/ZX8Gi/9h0p/JfvKS/+h0rubN23pzUs/a+ndzZu29O7mTVt6d/OmLb27edOW3t28WUuv7uZNW3p386Ytvbt505be3bxpS29e+llL727etKV3N2/a0rubN23p3c2btvTu5s1a+uhu3rSldzdv2tK7mzdt6d3Nm7b05qWftfTu5k1benfzpi29u3nTlt7dvGlL727erKU3d/OmLb27edOW3t28aUvvbt60pTcv/ayldzdv2tK7mzdt6d3Nm7b07uZNW3p382YtfXI3b9rSu5s3bendzZu29O7mTVt689LPWnp386Ytvbt505be3bxpS+9u3rSldzdv1tJnd/OmLb27edOW3t28aUvvbt60pTcv/ayldzdv2tK7mzdt6d3Nm7b07uZNW3p382YtfXE3b9rSu5s3bendzZu29O7mTVt689LPWnp386Ytvbt505be3bxpS+9u3rSldzdv1tJXd/OmLb27edOW3t28aUvvbt60pTcv/ayldzdv2tK7mzdt6d3Nm7b07uZNW3p382YtfXM3b9rSu5s3bendzZu29O7mTVt689LPWnp386Ytvbt505be3bxpS+9u3rSldzdv0tJrcDdv2tK7mzdt6d3Nm7b07uZNW3rz0s9aenfzpi29u3nTlt7dvGlL727etKV3N2/W0ou7edOW3t28aUvvbt60pXc3b9rSm5d+1tK7mzdt6d3Nm7b07uZNW3p386Ytvbt5s5Ze3c2btvTu5k1benfzpi29u3nTlt689LOW3t28aUvvbt60pXc3b9rSu5s3bendzZu19NHdvGlL727etKV3N2/a0rubN23pzUs/a+ndzZu29O7mTVt6d/OmLb27edOW3t28WUtv7uZNW3p386Ytvbt505be3bxpS29e+llL727etKV3N2/a0rubN23p3c2btvTu5s1a+uRu3rSldzdv2tK7mzdt6d3Nm7b05qWftfTu5k1benfzpi29u3nTlt7dvGlL727erKXP7uZNW3p386Ytvbt505be3bxpS29e+llL727etKV3N2/a0rubN23p3c2btvTu5s1a+uJu3rSldzdv2tK7mzdt6d3Nm7b05qWftfTu5k1benfzpi29u3nTlt7dvGlL727erKWv7uZNW3p386Ytvbt505be3bxpS29e+llL727etKV3N2/a0rubN23p3c2btvTu5s1a+uZu3rSldzdv2tK7mzdt6d3Nm7b05qWftfTu5k1benfzpi29u3nTlt7dvGlL727epKWPwd28aUvvbt60pae7eUF6pf8aP9uS0hTz+uq7Wm1PXVG129VqfJszMaatiR7r7dXNQrmLZGsy5nC7yJjl7iLr1ovV9PZitXr/4q9JN0/685POtmEumnS2AXLRpLOth5MmPZbbO8d4H/Ut6eyb/osmnX27fdKkm6xJXxyN91+sNd7eWZeefufFYrd3VsnyUE5h30J7OX94sUq8vVjvby62XpzK7bWptfvL+1p59h20V/7zKs++gfbKf17l3Xo4V+XT6rFp1Z+qvHnlJ628mzCnqnxc7X2NrTw27G7vXKqcbhxdqpxuSZ2qnCnomg+T91+8VG79TjeH+Fh7d8amrb26jXbd2pe1ilLuU/3xXlzdc/Np8humiRt0Pk1+wzRxN+/C02QtvZT2U6avmk8Tnyb708R9wpdPkzdzodadd977Yl/dJzxVOcd9yaduKc5aeXcfz1X5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","brillig_names":["store_in_execution_cache_oracle_wrapper","call_private_function_internal","load","store_in_execution_cache_oracle_wrapper","store_in_execution_cache_oracle_wrapper","enqueue_public_function_call_internal","build_msg_block","attach_len_to_msg_block","storage_read","get_public_data_witness","field_less_than","decompose_hint","lte_hint","directive_invert","directive_to_radix","directive_integer_quotient"]},{"name":"swap_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"input_asset_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"input_amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"private"},{"name":"output_asset_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce_for_transfer_approval","type":{"kind":"field"},"visibility":"private"},{"name":"uniswap_fee_tier","type":{"kind":"field"},"visibility":"private"},{"name":"minimum_output_amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_L1","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce_for_swap_approval","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"939615093317106671":{"error_kind":"string","string":"Invalid response from registry"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4939791462094160055":{"error_kind":"string","string":"Message not authorized by account"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7952883935970497419":{"error_kind":"string","string":"L1 portal address of output_asset's bridge is 0"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17695220409134080280":{"error_kind":"string","string":"L1 portal address of input_asset's bridge is 0"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["swap_public"]},{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"log_plaintext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8861757336002045335":{"error_kind":"fmtstring","length":99,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"9862881900111276825":{"error_kind":"fmtstring","length":35,"item_types":[{"kind":"field"}]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["process_log"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==","debug_symbols":"bY/dCoMwDIXfJde9aOz8ma8iQ6pGKZRWah0M8d0Xh2xu8+aQE74cchboqJmH2rjeT1BWC1jf6mi8Y7esAppgrDVDfVyD3ATVi59G7TY7RR0ilEopAeQ6ni7I972xBGWWrOIPRSmLYodRIqZvHNNzHvP8w1+zL/62sr3rYHRjaX++n1176BIfI/3UGoNvqZsDbQUP3VgrTEUiOZajnw==","brillig_names":["sync_notes"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"portal_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7V3bbhs5DP0XP+dBokhd+iuLRZG22cJAkBRpusCi6L/v2JvROB55tOIotSbiSxAnOh7qHFoiOR7q5+7L3acfXz/uH/56/L778MfP3f3j59vn/ePD8Ornr5vdp6f9/f3+68fTP+/U4Yem4/jv324fDi+/P98+Pe8+aGvhZnf38OXwq4PhHf7a39/tPlj49efNTlsGxjEwnoEJ5RhQDIxmYICBMQwMMjAMPwCGH0CpH9zMB5ML42AKIQ7WGhOjEdG9jEYkG0d7kxjsjaKXwd6APh18sN2vt93CNNhSxnYw3ryMBjQnozH53s7Z8b092FejB+tNZetPBqetd3Y0fjAsjiV9NCY0ZAyqlozR641xKjqCsypjjNGgX0Yb7THjZKBh/PCBDurcyUhVtt6toJJ0S8ZAS8aY9cZ4MHG1MdlVOMC4sGJAXF6FtQKK760g4Nk6TLhp62nT1ttNW+82bb3ftPVhy9ZbtWnr9W+33o/Wk1Lq3BxoyxzTljm/f3sjO5mjl13NhtEMpyY3A32MKyxt1/QaGxtOplvMmE7aRCfQNmN6mR251cD1M1Xfz1RDN1N1qp+p6n6mCu9mquDcOBhON7HgUkVHi+Me5u1JSQWcTu14fooLvZmmaIbfDyQaIXE9iSgkrieRhMT/Q6IKkUSAGYnvJyq9IonvJ969IonvJ5K+IonvJ0a/Hon+/UT/VyTx/eQVVyRRMpYKJErGUoFEFBLXk9htxhIiic6YDIkeIY5Gh5nRJtbnEU7ksSmbdcDRZtBwOvggTreZ0BbE6TbD2oI43WZuWxCn24xwA+KEbjPNLYjTbQa7BXG6zYy3IE63GfcWxEERp11xpELQsDhSIWhYHKkQNCyOVAgaFkcqBO2Ko5WUCFpWR2oELasjRYKW1ZEqQcvqoKjTsDpSJ2hZHSkUtKyOVApaVkdKBS2rI7WChtXRUitoWR2pFbSsjtQKWlZHagUtqyMR9VXVATOpg3SuDkhUcFV1nI4NLV+Z8aKORAUtqyNRQcvqSFTQsjoo6jSsjtxBaFkduYPQsjqS77SsjtxBaFkduYPQsDqmxvEKgSZ1cocIGKWmwyEgN7pqNwZtdE+ThZ4ma3qaLPY0WeppsranybqeJut7mmzoaLLYUwSFPUVQuN0I6mj+dmOio/m4bfNbj1u28D0DbD0e2gSJrcdZmyCx9fhtEyS2HhdugURqPd7cBImtx7GbILH1+HgTJLYepW+CRBQS15MoGUsFEiVjqUCiZCwVSJSMpQKJkrGsJ9FKxlKBRMlYKpAoGUsFEiVjqUAiConrSZSMpQKJkrFUIFEylgokSsZSgUTJWNaT6CRjqUCiZCwVSJSMpQKJkrFUIFHixPWtOZzszuufWfKyO1cgUXbnCiTK7lyBRNmdK5CIQuJ6EqWeWIFEiRMrkCj1xAokSj2xAok12jd4NQ4O2r6i5XCJKociZy6h3/4SFWLB4Hy8RMCM/1iNo7dZTZNBQC8GrY+rQOmx8QYoozMGoYXRoOHXqT1GsvGGN7GXhjfenQ4+Go8VjI+fxsF4kzFeKzd+DPRxxDmbVENeNxmEcw+yb38J9/aXSK+6ysWFVCufUS5AvESgyR5tU57kjB+d1KHCZbdzQ842Dh6qXMuDB0uNmay2dualoZu5woVz6crmGsYldNgq6dVcj5fQb38JePtLmNWXMMO90BhInG4EaafwZtztnSefcQprxnXOnT63esEpNMK0KnozcwrsaK60fq4QNxkzuFFmrlphjDiUPVkaArZzXwAunH3UPS1OaEnR4oWWFC1BaEnQopXQkqJFCy0pWkBoSdFihJYULSi0pGiRKDdJi0S5SVokyk3SIlFukhaJclO0gES5SVokyk3SIlFukhaJcpO0oNCSokWi3CQtEuUmaZEoN0mLRLlJWiTKTdFiJMpN0iJRbpIWiXKTtEiUm6QFO6UFQjyQyiia0dJrlJuhpdcoN0NLr1FuhpZeo9wMLb1Gucu0YK9RboaWXqPcDC29RrkZWnqNcjO0YKe0LD6hBNhrlJuhpdcoN0NLr1FuhpZeo9wMLb1Gucu0UK9RboaWXqPcDC29RrkZWnqNcjO0YAVa4qOMBihHyxUfKSPqaK62o7muf8ya7PjwOvlcJwBEHJ8hRiS7bLwfMsvxc21ePxV8NH190wwKo0pWU850iPNE8BnTA8Z3DgR0brp09/9fy69RNhYZThsd/Lf8Snf/GiSikLieROnGVYFE6cZVgUTpxlWBROnGVYFE6R+8/j6KdPevQaL0D65AomQsFUiUjKUCiSgkridRMpYKJErGUoFEyVgqkCgZy3oS5bCOGiRW2Fg8monE3B0F0maknLTNtQ4t6srrYt9f8Ga6hxPcZpPyGh3vRZ03U8eJOg2r40WdhtUJok676lQ5N0HUeSt1tKjTsDog6rSb71Q4ukTUeTt1UNRpWB2pFbSsjtQKWlZHagUtqyO1gpbVkVpBu+oYJbWCltWRWkHL6kg22rA66eNNKBpDJ/eARwiWQ6gcYsshrhziyyGhGJJuUb8M0eUQKIeUqw/l6qfbRZMdH6elkw/pCLHlEFcOSasfmyXaWa9Ek25PuwhJt25dhuhyCJRDTDkEyyFUDrHlEFcOKVfflKuP5eqnGyEsP/ht6FJJPu6c1s8+AGQ4IOSAiAOyHFC6CuHcuEIdvhA1A3kOKDBAVnFAmgMCDshwQMgBEQdkOSCOR1iOR1iORziORziORziORziOR1z4QnzQMdgOMAcRB2Q5IMcAXfjCgIrLslbWz0CaA0rrpE+OGKfZunfhrl8GhBwQcUCWA0rrpO3U9cKfs4cXygGoYvuWYcgMBByQ4YCQA0pTThDZI1IzkOWAHAfkOaDAAF040zYD0hwQcECGA0IOiOMRF85hpFjW0BRgBnIckOeAAgN04fy3DEhzQMABGQ4oLa6Z9qchRZyBLAfkOCDPAQUG6MKxJxmQ5oCAAzIcEHJAHI8wHI+40MjexCZJeshhZiDPAQUG6EKL8AxIc0DAARkOCDkgYsQRF9raZkCOA/IMUDqjdlNzMTyve2A6yw2xw1ggmkFMOQTLIVQOseXJAl7IbjMgzwEFBsgpDkhzQMABGQ4IOSDigDge4Tge4Tge4Tge4Tke4Tke4U3xcuLTH3Q1lmsDzCHlH/T0czvLVwnFkHTBYhmiyyHlC3AoX4BD+QIcynVJFymWIa4c4sshafVp9OTgznMISn9nZRmiyyFQDjHlECyHUDkkp34CUqw+KV8OCcWQdJ1kGaLLIVAOMeUQLIdQOcSWQ8rV1+Xq63L1oVx9KFT/1/Dq79un/e2n+7vvA+Lwzx8Pn5/3jw8vL5//+Tb+59PT/v5+//Xjt6fHz3dffjzdfbx//Hz43069/PiDgG4I7WDK0XUPzx8ZrQ8vD4bRkAoRhuGqw5X/BQ==","brillig_names":["constructor"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Uniswap::_approve_bridge_and_exit_input_asset_to_L1_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Uniswap::_approve_bridge_and_exit_input_asset_to_L1_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"token_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Uniswap::swap_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Uniswap::swap_public_parameters","fields":[{"name":"sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"input_asset_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"input_amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}},{"name":"output_asset_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce_for_transfer_approval","type":{"kind":"field"}},{"name":"uniswap_fee_tier","type":{"kind":"field"}},{"name":"minimum_output_amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"}},{"name":"caller_on_L1","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce_for_swap_approval","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Uniswap::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Uniswap::constructor_parameters","fields":[{"name":"portal_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Uniswap::swap_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Uniswap::swap_private_parameters","fields":[{"name":"input_asset","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"input_asset_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"input_amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}},{"name":"output_asset_bridge","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce_for_transfer_to_public_approval","type":{"kind":"field"}},{"name":"uniswap_fee_tier","type":{"kind":"field"}},{"name":"minimum_output_amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"}},{"name":"caller_on_L1","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]}],"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"TokenBridge"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"config","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Uniswap"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]}]}},"file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"51":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"52":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"57":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"60":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\nuse crate::static_assert;\nuse super::{convert::AsPrimitive, default::Default};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        static_assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                /// Safety: optionally adds 32 and then check (below) the result is in 'a..f' range\n                let ascii =\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128\n    where\n        T: AsPrimitive<Field>,\n    {\n        let f = i.as_();\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T\n    where\n        Field: AsPrimitive<T>,\n    {\n        AsPrimitive::as_(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        /// Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n        /// Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        /// Safety: cf div() above\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nimpl Default for U128 {\n    fn default() -> Self {\n        U128::zero()\n    }\n}\n\nmod tests {\n    use crate::default::Default;\n    use crate::ops::Not;\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        /// Safety: testing context\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq(U128::default(), U128::zero());\n    }\n}\n","path":"std/uint128.nr"},"62":{"source":"// docs:start:uniswap_setup\nmod util;\n\n// Demonstrates how to use portal contracts to swap on L1 Uniswap with funds on L2\n// Has two separate flows for private and public respectively\n// Uses the token bridge contract, which tells which input token we need to talk to and handles the exit funds to L1\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Uniswap {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector, PublicImmutable};\n\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit_public, compute_authwit_message_hash_from_call,\n        set_authorized,\n    };\n\n    use crate::util::{compute_swap_private_content_hash, compute_swap_public_content_hash};\n    use dep::aztec::macros::{functions::{initializer, internal, private, public}, storage::storage};\n    use dep::token::Token;\n    use dep::token_bridge::TokenBridge;\n\n    #[storage]\n    struct Storage<Context> {\n        portal_address: PublicImmutable<EthAddress, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal_address: EthAddress) {\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:uniswap_setup\n\n    // docs:start:swap_public\n    #[public]\n    fn swap_public(\n        sender: AztecAddress,\n        input_asset_bridge: AztecAddress,\n        input_amount: U128,\n        output_asset_bridge: AztecAddress,\n        // params for using the transfer approval\n        nonce_for_transfer_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field,\n        minimum_output_amount: U128,\n        // params for the depositing output_asset back to Aztec\n        recipient: AztecAddress,\n        secret_hash_for_L1_to_l2_message: Field,\n        caller_on_L1: EthAddress,\n        // nonce for someone to call swap on sender's behalf\n        nonce_for_swap_approval: Field,\n    ) {\n        if (!sender.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, sender);\n        }\n\n        let input_asset_bridge_config =\n            TokenBridge::at(input_asset_bridge).get_config_public().view(&mut context);\n\n        let input_asset = input_asset_bridge_config.token;\n        let input_asset_bridge_portal_address = input_asset_bridge_config.portal;\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_in_public(\n                sender,\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .call(&mut context);\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n        let output_asset_bridge_portal_address =\n            TokenBridge::at(output_asset_bridge).get_config_public().view(&mut context).portal;\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        assert(\n            !output_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of output_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_swap_public_content_hash(\n            input_asset_bridge_portal_address,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_portal_address,\n            minimum_output_amount,\n            recipient,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read(), content_hash);\n    }\n    // docs:end:swap_public\n\n    // docs:start:swap_private\n    #[private]\n    fn swap_private(\n        input_asset: AztecAddress, // since private, we pass here and later assert that this is as expected by input_bridge\n        input_asset_bridge: AztecAddress,\n        input_amount: U128,\n        output_asset_bridge: AztecAddress,\n        // params for using the transfer_to_public approval\n        nonce_for_transfer_to_public_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field, // which uniswap tier to use (eg 3000 for 0.3% fee)\n        minimum_output_amount: U128, // minimum output amount to receive (slippage protection for the swap)\n        // params for the depositing output_asset back to Aztec\n        secret_hash_for_L1_to_l2_message: Field, // for when l1 uniswap portal inserts the message to consume output assets on L2\n        caller_on_L1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n    ) {\n        let input_asset_bridge_config =\n            TokenBridge::at(input_asset_bridge).get_config().view(&mut context);\n        let output_asset_bridge_config =\n            TokenBridge::at(output_asset_bridge).get_config().view(&mut context);\n\n        // Assert that user provided token address is same as expected by token bridge.\n        // we can't directly use `input_asset_bridge.token` because that is a public method and public can't return data to private\n        assert(\n            input_asset.eq(input_asset_bridge_config.token),\n            \"input_asset address is not the same as seen in the bridge contract\",\n        );\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_to_public(\n                context.msg_sender(),\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_to_public_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .enqueue(&mut context);\n\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_config.portal.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        assert(\n            !output_asset_bridge_config.portal.is_zero(),\n            \"L1 portal address of output_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_swap_private_content_hash(\n            input_asset_bridge_config.portal,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_config.portal,\n            minimum_output_amount,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read(), content_hash);\n    }\n    // docs:end:swap_private\n\n    // docs:start:authwit_uniswap_set\n    // This helper method approves the bridge to burn this contract's funds and exits the input asset to L1\n    // Assumes contract already has funds.\n    // Assume `token` relates to `token_bridge` (ie token_bridge.token == token)\n    // Note that private can't read public return values so created an internal public that handles everything\n    // this method is used for both private and public swaps.\n    #[public]\n    #[internal]\n    fn _approve_bridge_and_exit_input_asset_to_L1(\n        token: AztecAddress,\n        token_bridge: AztecAddress,\n        amount: U128,\n    ) {\n        // Since we will authorize and instantly spend the funds, all in public, we can use the same nonce\n        // every interaction. In practice, the authwit should be squashed, so this is also cheap!\n        let nonce = 0xdeadbeef;\n\n        let selector = FunctionSelector::from_signature(\"burn_public((Field),Field,Field)\");\n        let serialized_amount = amount.serialize();\n        let message_hash = compute_authwit_message_hash_from_call(\n            token_bridge,\n            token,\n            context.chain_id(),\n            context.version(),\n            selector,\n            [context.this_address().to_field(), serialized_amount[0], serialized_amount[1], nonce],\n        );\n\n        // We need to make a call to update it.\n        set_authorized(&mut context, message_hash, true);\n\n        let this_portal_address = storage.portal_address.read();\n        // Exit to L1 Uniswap Portal !\n        TokenBridge::at(token_bridge)\n            .exit_to_l1_public(this_portal_address, amount, this_portal_address, nonce)\n            .call(&mut context)\n    }\n    // docs:end:authwit_uniswap_set\n}","path":"/Users/nathalia/Personal/cryptography/aztec/aztec-private-counter/contracts/uniswap/src/main.nr"},"64":{"source":"// docs:start:uniswap_public_content_hash\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// This method computes the L2 to L1 message content hash for the public\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_public_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: U128,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: U128,\n    aztec_recipient: AztecAddress,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 260]; // 8 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_field().to_be_bytes();\n    let uniswap_fee_tier_bytes: [u8; 32] = uniswap_fee_tier.to_be_bytes();\n    let output_token_portal_bytes: [u8; 32] =\n        output_asset_bridge_portal_address.to_field().to_be_bytes();\n    let amount_out_min_bytes: [u8; 32] = minimum_output_amount.to_field().to_be_bytes();\n    let aztec_recipient_bytes: [u8; 32] = aztec_recipient.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime {\n        keccak256::keccak256(\n            \"swap_public(address,uint256,uint24,address,uint256,bytes32,bytes32,address)\".as_bytes(),\n            75,\n        )\n    };\n\n    hash_bytes[0] = selector[0];\n    hash_bytes[1] = selector[1];\n    hash_bytes[2] = selector[2];\n    hash_bytes[3] = selector[3];\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = aztec_recipient_bytes[i];\n        hash_bytes[i + 196] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 228] = caller_on_L1_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:uniswap_public_content_hash\n\n// docs:start:compute_swap_private_content_hash\n// This method computes the L2 to L1 message content hash for the private\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_private_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: U128,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: U128,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 228]; // 7 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_field().to_be_bytes();\n    let uniswap_fee_tier_bytes: [u8; 32] = uniswap_fee_tier.to_be_bytes();\n    let output_token_portal_bytes: [u8; 32] =\n        output_asset_bridge_portal_address.to_field().to_be_bytes();\n    let amount_out_min_bytes: [u8; 32] = minimum_output_amount.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime {\n        keccak256::keccak256(\n            \"swap_private(address,uint256,uint24,address,uint256,bytes32,address)\".as_bytes(),\n            68,\n        )\n    };\n\n    hash_bytes[0] = selector[0];\n    hash_bytes[1] = selector[1];\n    hash_bytes[2] = selector[2];\n    hash_bytes[3] = selector[3];\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 196] = caller_on_L1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:compute_swap_private_content_hash\n\n","path":"/Users/nathalia/Personal/cryptography/aztec/aztec-private-counter/contracts/uniswap/src/util.nr"},"66":{"source":"use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/authwit/src/auth.nr"},"75":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"82":{"source":"use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"83":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"84":{"source":"use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr"},"85":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"97":{"source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/hash.nr"},"104":{"source":"use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        /// Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"108":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"114":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"123":{"source":"use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |packed_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::unpack_content,\n///             note_header,\n///             true,\n///             storage_slot,\n///             packed_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, packed_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                header,\n                storage_slot,\n                note_type_id,\n            )\n                .unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        packed_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let packed_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, packed_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr"},"134":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header, storage_slot);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash(storage_slot);\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note, storage_slot: Field) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note, storage_slot);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    unpack_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    storage_slot: Field,\n    packed_note_content: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = unpack_content(array::subarray(packed_note_content, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash(storage_slot);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context(storage_slot)\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"137":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"139":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"140":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"141":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"142":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"146":{"source":"use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"147":{"source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"148":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"151":{"source":"use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr"},"152":{"source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note_content,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note_content: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::unpack_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"154":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"163":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: U128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr"},"185":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"186":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"194":{"source":"use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            /// Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr"},"211":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"247":{"source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"254":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"255":{"source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"269":{"source":"use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr"},"271":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"281":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"287":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"288":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"297":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"313":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"317":{"source":"use crate::traits::{Packable, ToField};\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for U128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self.to_field()]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"318":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        // The below warning is due to visibility in noir stdlib.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"334":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    /// Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"335":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"337":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"349":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"353":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\npub contract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::log_assembly_strategies::default_aes128::{\n            event::encode_and_encrypt_event_unconstrained,\n            note::{encode_and_encrypt_note, encode_and_encrypt_note_unconstrained},\n        },\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n    };\n\n    use dep::uint_note::uint_note::UintNote;\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::balance_set::BalanceSet;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: U128,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: PublicImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> U128 {\n        storage.total_supply.read()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> U128 {\n        storage.public_balances.at(owner).read()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_to_public\n    #[public]\n    fn mint_to_public(to: AztecAddress, amount: U128) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_to_public\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_in_public\n\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: U128, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: U128) {\n        let from = context.msg_sender();\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from,\n            from,\n        ));\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_in_private`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount }.emit(encode_and_encrypt_event_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::zero(), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining)\n    }\n\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: U128) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            amount,\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:burn_private\n    #[private]\n    fn burn_private(from: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn_private\n\n    // docs:start:transfer_to_private\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    #[private]\n    fn transfer_to_private(to: AztecAddress, amount: U128) {\n        // `from` is the owner of the public balance from which we'll subtract the `amount`.\n        let from = context.msg_sender();\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_private\n\n    // docs:start:prepare_private_balance_increase\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_to_private`, `finalize_mint_to_private`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n    // docs:end:prepare_private_balance_increase\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = UintNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let setup_log = note_setup_payload.encrypt_log(context, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // docs:start:finalize_transfer_to_private\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_to_private(amount: U128, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    /// This is a wrapper around `_finalize_transfer_to_private` placed here so that a call\n    /// to `_finalize_transfer_to_private` can be enqueued. Called unsafe as it does not check `from` (this has to be\n    /// done in the calling function).\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:mint_to_private\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueued call).\n    #[private]\n    fn mint_to_private(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        amount: U128,\n    ) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_to_private_unsafe(context.msg_sender(), amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n    // docs:end:mint_to_private\n\n    // docs:start:finalize_mint_to_private\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_to_public`\n    /// and `finalize_transfer_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_to_private(amount: U128, hiding_point_slot: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private\n\n    // docs:start:finalize_mint_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_mint_to_private_unsafe(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_to_private` function.\n        assert(storage.minters.at(from).read(), \"caller is not minter\");\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_mint_to_private(\n        amount: U128,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // First we increase the total supply by the `amount`\n        let supply = storage.total_supply.read().add(amount);\n        storage.total_supply.write(supply);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: U128) {\n        _increase_public_balance_inner(to, amount, storage);\n    }\n    // docs:end:increase_public_balance\n\n    #[contract_library_method]\n    fn _increase_public_balance_inner(\n        to: AztecAddress,\n        amount: U128,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n    }\n\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: U128) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub U128 {\n        storage.balances.at(owner).balance_of()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"372":{"source":"use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress,\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n        traits::{Packable, Serialize},\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\n#[derive(Serialize)]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self, storage_slot: Field) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self, storage_slot);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/uint-note/src/uint_note.nr"},"374":{"source":"mod config;\n\n// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract TokenBridge {\n    use crate::config::Config;\n\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_to_private_content_hash, get_mint_to_public_content_hash,\n        get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{functions::{initializer, private, public, view}, storage::storage};\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal: EthAddress) {\n        storage.config.initialize(Config { token, portal });\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    // docs:start:get_config\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n    // docs:end:get_config\n\n    #[public]\n    #[view]\n    fn get_config_public() -> Config {\n        storage.config.read()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: U128, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_to_public_content_hash(to, amount);\n\n        let config = storage.config.read();\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, config.portal, message_leaf_index);\n\n        // Mint tokens\n        Token::at(config.token).mint_to_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: U128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        let config = storage.config.read();\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(config.token).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n\n    // docs:start:claim_private\n    /// Claims the bridged tokens and makes them accessible in private. Note that recipient's address is not revealed\n    /// but the amount is. Hence it's most likely possible to determine to which L1 deposit this claim corresponds to\n    /// (unless there are multiple pending deposits of the same amount).\n    #[private]\n    fn claim_private(\n        recipient: AztecAddress, // recipient of the bridged tokens\n        amount: U128,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n        message_leaf_index: Field,\n    ) {\n        let config = storage.config.read();\n\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_to_private_content_hash(amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            config.portal,\n            message_leaf_index,\n        );\n\n        // At last we mint the tokens\n        // docs:start:call_mint_on_token\n        Token::at(config.token).mint_to_private(context.msg_sender(), recipient, amount).call(\n            &mut context,\n        );\n        // docs:end:call_mint_on_token\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: U128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // docs:start:assert_token_is_same\n        let config = storage.config.read();\n\n        // Assert that user provided token address is same as seen in storage.\n        assert_eq(config.token, token, \"Token address is not the same as seen in storage\");\n        // docs:end:assert_token_is_same\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(token).burn_private(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_private\n}\n","path":"/Users/nathalia/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-contracts/contracts/token_bridge_contract/src/main.nr"}}}